{"version":3,"sources":["../../node_modules/@onekeyfe/hd-ble-sdk/dist/index.js","../../node_modules/@onekeyfe/hd-transport-react-native/dist/index.js","../../node_modules/react-native-ble-plx/src/Utils.js","../../node_modules/react-native-ble-plx/src/BleError.js","../../node_modules/react-native-ble-plx/src/TypeDefinition.js","../../node_modules/react-native-ble-plx/src/Device.js","../../node_modules/react-native-ble-plx/src/Service.js","../../node_modules/react-native-ble-plx/src/Descriptor.js","../../node_modules/react-native-ble-plx/src/Characteristic.js","../../node_modules/react-native-ble-plx/src/BleModule.js","../../node_modules/react-native-ble-plx/src/BleManager.js"],"names":["Object","defineProperty","exports","value","HardwareSdk","hdShared","ReactNativeTransport","_interopDefaultLegacy","e","HardwareSdk__default","ReactNativeTransport__default","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","then","apply","ReflectOwnKeys","events","R","Reflect","ReflectApply","target","receiver","args","Function","prototype","call","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","EventEmitter","init","this","once","emitter","name","errorListener","err","removeListener","resolver","slice","arguments","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","m","existing","create","newListener","emit","unshift","push","length","warned","w","Error","String","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","Array","i","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","eventEmitter","Log","initLog","_core","_settings","parseConnectSettings","_messageID","messagePromises","handleMessage","event","debug","UI_EVENT","payload","log","postMessage","usePromise","ERRORS","TypedError","createDeferred","assign","id","HardwareBleSdk","settings","env","enableLog","initCore","CORE_EVENT","createErrorMessage","params","_a","_b","response","IFRAME","CALL","success","code","HardwareErrorCode","BlePermissionError","createUiMessage","UI_REQUEST","BLUETOOTH_PERMISSION","BleLocationError","LOCATION_PERMISSION","CallMethodNotResponse","cancel","connectId","CANCEL","dispose","uiResponse","NotInitialized","reactNative","buffer","reactNativeBlePlx","ByteBuffer","transport","BleManager","ByteBuffer__default","transport__default","BleManager__default","timer","timeout","fn","ms","setTimeout","clearTimeout","subscribeBleOn","bleManager","subscription","onStateChange","remove","OneKeyServices","classic","serviceUuid","writeUuid","notifyUuid","bluetoothServices","deviceType","services","getBluetoothServiceUuids","getInfosForServiceUuid","service","BleTransport","device","writeCharacteristic","notifyCharacteristic","mtuSize","check","buildBuffers","receiveOne","parseConfigure","transportCache","connectOptions","requestMTU","module","options","configured","stopped","scanTimeout","runPromise","signedData","messages","_messages","blePlxManager","start","showAlert","deviceList","getPlxManager","serviceUuids","startDeviceScan","scanMode","ScanMode","LowLatency","BleErrorCode","BluetoothPoweredOff","BluetoothInUnknownState","includes","errorCode","BluetoothUnauthorized","BleScanError","reason","startsWith","exec","isOnekeyDevice","localName","addDevice","getConnectedPeripherals","map","peripheral","advertising","devices","every","d","stopDeviceScan","input","uuid","BleRequiredUUID","release","deviceFilter","connectedDevices","filter","connectToDevice","DeviceMTUChangeFailed","OperationCancelled","BleConnectedError","isConnected","connect","Platform","OS","getBondedPeripherals","find","bondedDevice","discoverAllServicesAndCharacteristics","characteristics","infos","serviceUUIDs","serviceUUID","tryToGetConfiguration","characteristicsForService","BleServiceNotFound","BleCharacteristicNotFound","c","isWritableWithResponse","isNotifiable","nofitySubscription","_monitorCharacteristic","disconnectSubscription","onDisconnected","characteristic","bufferLength","buffer$1","monitor","_c","BleCharacteristicNotifyError","BleMonitorError","data","Buffer","from","chunk","MagicQuestionMark","sharp1","sharp2","fromCharCode","MESSAGE_TOP_CHAR","MESSAGE_HEADER_BYTE","isHeaderChunk","readInt32BE","subarray","COMMON_HEADER_SIZE","toString","cancelDeviceConnection","TransportNotConfigured","TransportCallInProgress","TransportNotFound","buffers","packetCapacity","allocate","toBuffer","append","offset","reset","writeWithoutResponse","o","outData","DeviceDisconnected","BleDeviceNotBonded","promise","jsonData","fullUUID","toLowerCase","BleError","nativeBleError","errorMessageMapping","object","UnknownError","attErrorCode","iosErrorCode","androidErrorCode","replace","_","parseBleError","errorMessage","bleError","errorMapping","BleErrorCodeMessage","JSON","parse","parseError","BluetoothManagerDestroyed","OperationTimedOut","OperationStartFailed","InvalidIdentifiers","BluetoothUnsupported","BluetoothResetting","BluetoothStateChangeFailed","DeviceConnectionFailed","DeviceRSSIReadFailed","DeviceAlreadyConnected","DeviceNotFound","DeviceNotConnected","ServicesDiscoveryFailed","IncludedServicesDiscoveryFailed","ServiceNotFound","ServicesNotDiscovered","CharacteristicsDiscoveryFailed","CharacteristicWriteFailed","CharacteristicReadFailed","CharacteristicNotifyChangeFailed","CharacteristicNotFound","CharacteristicsNotDiscovered","CharacteristicInvalidDataFormat","DescriptorsDiscoveryFailed","DescriptorWriteFailed","DescriptorReadFailed","DescriptorNotFound","DescriptorsNotDiscovered","DescriptorInvalidDataFormat","DescriptorWriteNotAllowed","ScanStartFailed","LocationServicesDisabled","BleATTErrorCode","Success","InvalidHandle","ReadNotPermitted","WriteNotPermitted","InvalidPdu","InsufficientAuthentication","RequestNotSupported","InvalidOffset","InsufficientAuthorization","PrepareQueueFull","AttributeNotFound","AttributeNotLong","InsufficientEncryptionKeySize","InvalidAttributeValueLength","UnlikelyError","InsufficientEncryption","UnsupportedGroupType","InsufficientResources","BleIOSErrorCode","Unknown","InvalidParameters","NotConnected","OutOfSpace","ConnectionTimeout","PeripheralDisconnected","UuidNotAllowed","AlreadyAdvertising","ConnectionFailed","ConnectionLimitReached","UnknownDevice","BleAndroidErrorCode","NoResources","InternalError","WrongState","DbFull","Busy","CmdStarted","IllegalParameter","Pending","AuthFail","More","InvalidCfg","ServiceStarted","EncrypedNoMitm","NotEncrypted","Congested","Opportunistic","LowPower","Balanced","ScanCallbackType","AllMatches","FirstMatch","MatchLost","State","Resetting","Unsupported","Unauthorized","PoweredOff","PoweredOn","LogLevel","None","Verbose","Debug","Info","Warning","ConnectionPriority","High","Device","nativeDevice","manager","_manager","connectionPriority","transactionId","requestConnectionPriorityForDevice","readRSSIForDevice","mtu","requestMTUForDevice","isDeviceConnected","onDeviceDisconnected","discoverAllServicesAndCharacteristicsForDevice","servicesForDevice","characteristicsForDevice","characteristicUUID","descriptorsForDevice","readCharacteristicForDevice","valueBase64","writeCharacteristicWithResponseForDevice","writeCharacteristicWithoutResponseForDevice","monitorCharacteristicForDevice","descriptorUUID","readDescriptorForDevice","writeDescriptorForDevice","Service","nativeService","_characteristicsForService","_descriptorsForService","_readCharacteristicForService","_writeCharacteristicWithResponseForService","_writeCharacteristicWithoutResponseForService","_monitorCharacteristicForService","_readDescriptorForService","_writeDescriptorForService","Descriptor","nativeDescriptor","_readDescriptor","_writeDescriptor","Characteristic","nativeCharacteristic","_descriptorsForCharacteristic","_readCharacteristic","_writeCharacteristicWithResponse","_writeCharacteristicWithoutResponse","_readDescriptorForCharacteristic","_writeDescriptorForCharacteristic","BleModule","NativeModules","BleClientManager","NativeEventEmitter","_eventEmitter","_uniqueId","_activePromises","_activeSubscriptions","restoreStateFunction","restoreStateIdentifier","_nextUniqueID","RestoreStateEvent","nativeRestoredState","connectedPeripherals","_errorCodesToMessagesMapping","errorCodesToMessagesMapping","createClient","destroyedError","destroyClient","_scanEventSubscription","_destroySubscriptions","_destroyPromises","destroyPromise","race","logLevel","setLogLevel","_callPromise","cancelTransaction","enable","disable","wrappedSubscription","emitCurrentState","StateChangeEvent","cancelled","currentState","UUIDs","ScanEvent","deviceIdentifier","deviceIdentifiers","DisconnectionEvent","_handleCharacteristics","serviceIdentifier","characteristicsPromise","_handleDescriptors","descriptorsForService","characteristicIdentifier","descriptorsForCharacteristic","descriptorsPromise","readCharacteristicForService","readCharacteristic","base64Value","writeCharacteristicForDevice","writeCharacteristicForService","filledTransactionId","_handleMonitorCharacteristic","monitorCharacteristicForService","monitorCharacteristic","monitorPromise","ReadEvent","msgTransactionId","readDescriptorForService","readDescriptorForCharacteristic","descriptorIdentifier","readDescriptor","writeDescriptorForService","writeDescriptorForCharacteristic","writeDescriptor"],"mappings":"uFAEAA,OAAOC,eAAeC,EAAS,aAAc,CAAEC,OAAO,IAEtD,IAAIC,EAAc,EAAQ,KACtBC,EAAW,EAAQ,KACnBC,EAAuB,EAAQ,MAEnC,SAASC,EAAuBC,GAAK,OAAOA,GAAkB,kBAANA,GAAkB,YAAaA,EAAIA,EAAI,CAAE,QAAWA,GAE5G,IAAIC,EAAoCF,EAAsBH,GAC1DM,EAA6CH,EAAsBD,GAiBvE,SAASK,EAAUC,EAASC,EAAYC,EAAGC,GAEvC,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUhB,GAAS,IAAMiB,EAAKL,EAAUM,KAAKlB,IAAW,MAAOK,GAAKU,EAAOV,IACpF,SAASc,EAASnB,GAAS,IAAMiB,EAAKL,EAAiB,MAAEZ,IAAW,MAAOK,GAAKU,EAAOV,IACvF,SAASY,EAAKG,GAJlB,IAAepB,EAIaoB,EAAOC,KAAOP,EAAQM,EAAOpB,QAJ1CA,EAIyDoB,EAAOpB,MAJhDA,aAAiBW,EAAIX,EAAQ,IAAIW,GAAE,SAAUG,GAAWA,EAAQd,OAITsB,KAAKN,EAAWG,GAClGF,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,WAItE,IASIM,EATAC,EAAS,CAAC1B,QAAS,IAEnB2B,EAAuB,kBAAZC,QAAuBA,QAAU,KAC5CC,EAAeF,GAAwB,oBAAZA,EAAEH,MAC7BG,EAAEH,MACF,SAAsBM,EAAQC,EAAUC,GACxC,OAAOC,SAASC,UAAUV,MAAMW,KAAKL,EAAQC,EAAUC,IAKzDP,EADEE,GAA0B,oBAAdA,EAAES,QACCT,EAAES,QACVtC,OAAOuC,sBACC,SAAwBP,GACvC,OAAOhC,OAAOwC,oBAAoBR,GAC/BS,OAAOzC,OAAOuC,sBAAsBP,KAGxB,SAAwBA,GACvC,OAAOhC,OAAOwC,oBAAoBR,IAQtC,IAAIU,EAAcC,OAAOC,OAAS,SAAqBzC,GACrD,OAAOA,IAAUA,GAGnB,SAAS0C,IACPA,EAAaC,KAAKT,KAAKU,MAEzBnB,EAAO1B,QAAU2C,EACjBjB,EAAO1B,QAAQ8C,KAwYf,SAAcC,EAASC,GACrB,OAAO,IAAIlC,SAAQ,SAAUC,EAASC,GACpC,SAASiC,EAAcC,GACrBH,EAAQI,eAAeH,EAAMI,GAC7BpC,EAAOkC,GAGT,SAASE,IAC+B,oBAA3BL,EAAQI,gBACjBJ,EAAQI,eAAe,QAASF,GAElClC,EAAQ,GAAGsC,MAAMlB,KAAKmB,YAExBC,EAA+BR,EAASC,EAAMI,EAAU,CAAEN,MAAM,IACnD,UAATE,GAMR,SAAuCD,EAASS,EAASC,GAC7B,oBAAfV,EAAQW,IACjBH,EAA+BR,EAAS,QAASS,EAASC,GAPxDE,CAA8BZ,EAASE,EAAe,CAAEH,MAAM,QApZpEH,EAAaA,aAAeA,EAE5BA,EAAaT,UAAU0B,aAAUC,EACjClB,EAAaT,UAAU4B,aAAe,EACtCnB,EAAaT,UAAU6B,mBAAgBF,EAIvC,IAAIG,EAAsB,GAE1B,SAASC,EAAcC,GACrB,GAAwB,oBAAbA,EACT,MAAM,IAAIC,UAAU,0EAA4ED,GAsCpG,SAASE,EAAiBC,GACxB,YAA2BR,IAAvBQ,EAAKN,cACApB,EAAaqB,oBACfK,EAAKN,cAmDd,SAASO,EAAaxC,EAAQyC,EAAML,EAAUM,GAC5C,IAAIC,EACA/C,EACAgD,EAsBJ,GApBAT,EAAcC,QAGCL,KADfnC,EAASI,EAAO8B,UAEdlC,EAASI,EAAO8B,QAAU9D,OAAO6E,OAAO,MACxC7C,EAAOgC,aAAe,SAIKD,IAAvBnC,EAAOkD,cACT9C,EAAO+C,KAAK,cAAeN,EACfL,EAASA,SAAWA,EAASA,SAAWA,GAIpDxC,EAASI,EAAO8B,SAElBc,EAAWhD,EAAO6C,SAGHV,IAAba,EAEFA,EAAWhD,EAAO6C,GAAQL,IACxBpC,EAAOgC,kBAeT,GAbwB,oBAAbY,EAETA,EAAWhD,EAAO6C,GAChBC,EAAU,CAACN,EAAUQ,GAAY,CAACA,EAAUR,GAErCM,EACTE,EAASI,QAAQZ,GAEjBQ,EAASK,KAAKb,IAIhBO,EAAIL,EAAiBtC,IACb,GAAK4C,EAASM,OAASP,IAAMC,EAASO,OAAQ,CACpDP,EAASO,QAAS,EAGlB,IAAIC,EAAI,IAAIC,MAAM,+CACET,EAASM,OAAS,IAAMI,OAAOb,GADjC,qEAIlBW,EAAElC,KAAO,8BACTkC,EAAEnC,QAAUjB,EACZoD,EAAEX,KAAOA,EACTW,EAAEG,MAAQX,EAASM,OA5KnBM,SAAWA,QAAQC,KAiLvB,OAAOzD,EAcT,SAAS0D,IACP,IAAK3C,KAAK4C,MAGR,OAFA5C,KAAKf,OAAOqB,eAAeN,KAAK0B,KAAM1B,KAAK6C,QAC3C7C,KAAK4C,OAAQ,EACY,IAArBnC,UAAU0B,OACLnC,KAAKqB,SAAS/B,KAAKU,KAAKf,QAC1Be,KAAKqB,SAAS1C,MAAMqB,KAAKf,OAAQwB,WAI5C,SAASqC,EAAU7D,EAAQyC,EAAML,GAC/B,IAAI0B,EAAQ,CAAEH,OAAO,EAAOC,YAAQ7B,EAAW/B,OAAQA,EAAQyC,KAAMA,EAAML,SAAUA,GACjF2B,EAAUL,EAAYM,KAAKF,GAG/B,OAFAC,EAAQ3B,SAAWA,EACnB0B,EAAMF,OAASG,EACRA,EA0HT,SAASE,EAAWjE,EAAQyC,EAAMyB,GAChC,IAAItE,EAASI,EAAO8B,QAEpB,QAAeC,IAAXnC,EACF,MAAO,GAET,IAAIuE,EAAavE,EAAO6C,GACxB,YAAmBV,IAAfoC,EACK,GAEiB,oBAAfA,EACFD,EAAS,CAACC,EAAW/B,UAAY+B,GAAc,CAACA,GAElDD,EAsDT,SAAyBE,GAEvB,IADA,IAAIC,EAAM,IAAIC,MAAMF,EAAIlB,QACfqB,EAAI,EAAGA,EAAIF,EAAInB,SAAUqB,EAChCF,EAAIE,GAAKH,EAAIG,GAAGnC,UAAYgC,EAAIG,GAElC,OAAOF,EA1DLG,CAAgBL,GAAcM,EAAWN,EAAYA,EAAWjB,QAoBpE,SAASwB,EAAcjC,GACrB,IAAI7C,EAASmB,KAAKe,QAElB,QAAeC,IAAXnC,EAAsB,CACxB,IAAIuE,EAAavE,EAAO6C,GAExB,GAA0B,oBAAf0B,EACT,OAAO,EACF,QAAmBpC,IAAfoC,EACT,OAAOA,EAAWjB,OAItB,OAAO,EAOT,SAASuB,EAAWL,EAAKO,GAEvB,IADA,IAAIC,EAAO,IAAIN,MAAMK,GACZJ,EAAI,EAAGA,EAAII,IAAKJ,EACvBK,EAAKL,GAAKH,EAAIG,GAChB,OAAOK,EA2CT,SAASnD,EAA+BR,EAASC,EAAMkB,EAAUT,GAC/D,GAA0B,oBAAfV,EAAQW,GACbD,EAAMX,KACRC,EAAQD,KAAKE,EAAMkB,GAEnBnB,EAAQW,GAAGV,EAAMkB,OAEd,IAAwC,oBAA7BnB,EAAQ4D,iBAYxB,MAAM,IAAIxC,UAAU,6EAA+EpB,GATnGA,EAAQ4D,iBAAiB3D,GAAM,SAAS4D,EAAaC,GAG/CpD,EAAMX,MACRC,EAAQ+D,oBAAoB9D,EAAM4D,GAEpC1C,EAAS2C,OA/Zf/G,OAAOC,eAAe4C,EAAc,sBAAuB,CACzDoE,YAAY,EACZC,IAAK,WACH,OAAOhD,GAETiD,IAAK,SAASJ,GACZ,GAAmB,kBAARA,GAAoBA,EAAM,GAAKrE,EAAYqE,GACpD,MAAM,IAAIK,WAAW,kGAAoGL,EAAM,KAEjI7C,EAAsB6C,KAI1BlE,EAAaC,KAAO,gBAEGiB,IAAjBhB,KAAKe,SACLf,KAAKe,UAAY9D,OAAOqH,eAAetE,MAAMe,UAC/Cf,KAAKe,QAAU9D,OAAO6E,OAAO,MAC7B9B,KAAKiB,aAAe,GAGtBjB,KAAKkB,cAAgBlB,KAAKkB,oBAAiBF,GAK7ClB,EAAaT,UAAUkF,gBAAkB,SAAyBX,GAChE,GAAiB,kBAANA,GAAkBA,EAAI,GAAKjE,EAAYiE,GAChD,MAAM,IAAIS,WAAW,gFAAkFT,EAAI,KAG7G,OADA5D,KAAKkB,cAAgB0C,EACd5D,MASTF,EAAaT,UAAUmF,gBAAkB,WACvC,OAAOjD,EAAiBvB,OAG1BF,EAAaT,UAAU2C,KAAO,SAAcN,GAE1C,IADA,IAAIvC,EAAO,GACFqE,EAAI,EAAGA,EAAI/C,UAAU0B,OAAQqB,IAAKrE,EAAK+C,KAAKzB,UAAU+C,IAC/D,IAAIiB,EAAoB,UAAT/C,EAEX7C,EAASmB,KAAKe,QAClB,QAAeC,IAAXnC,EACF4F,EAAWA,QAA4BzD,IAAjBnC,EAAO6F,WAC1B,IAAKD,EACR,OAAO,EAGT,GAAIA,EAAS,CACX,IAAIE,EAGJ,GAFIxF,EAAKgD,OAAS,IAChBwC,EAAKxF,EAAK,IACRwF,aAAcrC,MAGhB,MAAMqC,EAGR,IAAItE,EAAM,IAAIiC,MAAM,oBAAsBqC,EAAK,KAAOA,EAAGC,QAAU,IAAM,KAEzE,MADAvE,EAAIwE,QAAUF,EACRtE,EAGR,IAAIM,EAAU9B,EAAO6C,GAErB,QAAgBV,IAAZL,EACF,OAAO,EAET,GAAuB,oBAAZA,EACT3B,EAAa2B,EAASX,KAAMb,OAE5B,KAAI2F,EAAMnE,EAAQwB,OACd4C,EAAYrB,EAAW/C,EAASmE,GACpC,IAAStB,EAAI,EAAGA,EAAIsB,IAAOtB,EACzBxE,EAAa+F,EAAUvB,GAAIxD,KAAMb,GAGrC,OAAO,GAiETW,EAAaT,UAAU2F,YAAc,SAAqBtD,EAAML,GAC9D,OAAOI,EAAazB,KAAM0B,EAAML,GAAU,IAG5CvB,EAAaT,UAAUwB,GAAKf,EAAaT,UAAU2F,YAEnDlF,EAAaT,UAAU4F,gBACnB,SAAyBvD,EAAML,GAC7B,OAAOI,EAAazB,KAAM0B,EAAML,GAAU,IAqBhDvB,EAAaT,UAAUY,KAAO,SAAcyB,EAAML,GAGhD,OAFAD,EAAcC,GACdrB,KAAKa,GAAGa,EAAMoB,EAAU9C,KAAM0B,EAAML,IAC7BrB,MAGTF,EAAaT,UAAU6F,oBACnB,SAA6BxD,EAAML,GAGjC,OAFAD,EAAcC,GACdrB,KAAKiF,gBAAgBvD,EAAMoB,EAAU9C,KAAM0B,EAAML,IAC1CrB,MAIbF,EAAaT,UAAUiB,eACnB,SAAwBoB,EAAML,GAC5B,IAAI8D,EAAMtG,EAAQuG,EAAU5B,EAAG6B,EAK/B,GAHAjE,EAAcC,QAGCL,KADfnC,EAASmB,KAAKe,SAEZ,OAAOf,KAGT,QAAagB,KADbmE,EAAOtG,EAAO6C,IAEZ,OAAO1B,KAET,GAAImF,IAAS9D,GAAY8D,EAAK9D,WAAaA,EACb,MAAtBrB,KAAKiB,aACTjB,KAAKe,QAAU9D,OAAO6E,OAAO,cAEtBjD,EAAO6C,GACV7C,EAAOyB,gBACTN,KAAKgC,KAAK,iBAAkBN,EAAMyD,EAAK9D,UAAYA,SAElD,GAAoB,oBAAT8D,EAAqB,CAGrC,IAFAC,GAAY,EAEP5B,EAAI2B,EAAKhD,OAAS,EAAGqB,GAAK,EAAGA,IAChC,GAAI2B,EAAK3B,KAAOnC,GAAY8D,EAAK3B,GAAGnC,WAAaA,EAAU,CACzDgE,EAAmBF,EAAK3B,GAAGnC,SAC3B+D,EAAW5B,EACX,MAIJ,GAAI4B,EAAW,EACb,OAAOpF,KAEQ,IAAboF,EACFD,EAAKG,QAiIf,SAAmBH,EAAMI,GACvB,KAAOA,EAAQ,EAAIJ,EAAKhD,OAAQoD,IAC9BJ,EAAKI,GAASJ,EAAKI,EAAQ,GAC7BJ,EAAKK,MAlIGC,CAAUN,EAAMC,GAGE,IAAhBD,EAAKhD,SACPtD,EAAO6C,GAAQyD,EAAK,SAEQnE,IAA1BnC,EAAOyB,gBACTN,KAAKgC,KAAK,iBAAkBN,EAAM2D,GAAoBhE,GAG1D,OAAOrB,MAGbF,EAAaT,UAAUqG,IAAM5F,EAAaT,UAAUiB,eAEpDR,EAAaT,UAAUsG,mBACnB,SAA4BjE,GAC1B,IAAIqD,EAAWlG,EAAQ2E,EAGvB,QAAexC,KADfnC,EAASmB,KAAKe,SAEZ,OAAOf,KAGT,QAA8BgB,IAA1BnC,EAAOyB,eAUT,OATyB,IAArBG,UAAU0B,QACZnC,KAAKe,QAAU9D,OAAO6E,OAAO,MAC7B9B,KAAKiB,aAAe,QACMD,IAAjBnC,EAAO6C,KACY,MAAtB1B,KAAKiB,aACTjB,KAAKe,QAAU9D,OAAO6E,OAAO,aAEtBjD,EAAO6C,IAEX1B,KAIT,GAAyB,IAArBS,UAAU0B,OAAc,CAC1B,IACIyD,EADAC,EAAO5I,OAAO4I,KAAKhH,GAEvB,IAAK2E,EAAI,EAAGA,EAAIqC,EAAK1D,SAAUqB,EAEjB,oBADZoC,EAAMC,EAAKrC,KAEXxD,KAAK2F,mBAAmBC,GAK1B,OAHA5F,KAAK2F,mBAAmB,kBACxB3F,KAAKe,QAAU9D,OAAO6E,OAAO,MAC7B9B,KAAKiB,aAAe,EACbjB,KAKT,GAAyB,oBAFzB+E,EAAYlG,EAAO6C,IAGjB1B,KAAKM,eAAeoB,EAAMqD,QACrB,QAAkB/D,IAAd+D,EAET,IAAKvB,EAAIuB,EAAU5C,OAAS,EAAGqB,GAAK,EAAGA,IACrCxD,KAAKM,eAAeoB,EAAMqD,EAAUvB,IAIxC,OAAOxD,MAoBbF,EAAaT,UAAU0F,UAAY,SAAmBrD,GACpD,OAAOwB,EAAWlD,KAAM0B,GAAM,IAGhC5B,EAAaT,UAAUyG,aAAe,SAAsBpE,GAC1D,OAAOwB,EAAWlD,KAAM0B,GAAM,IAGhC5B,EAAa6D,cAAgB,SAASzD,EAASwB,GAC7C,MAAqC,oBAA1BxB,EAAQyD,cACVzD,EAAQyD,cAAcjC,GAEtBiC,EAAcrE,KAAKY,EAASwB,IAIvC5B,EAAaT,UAAUsE,cAAgBA,EAiBvC7D,EAAaT,UAAU0G,WAAa,WAClC,OAAO/F,KAAKiB,aAAe,EAAIrC,EAAeoB,KAAKe,SAAW,IAyEhE,MAAMiF,EAAe,IAAInH,EAAO1B,QAC1B8I,EAAM5I,EAAY6I,QAAQ,sBAChC,IAAIC,EACAC,EAAY/I,EAAYgJ,uBACxBC,EAAa,EACjB,MAAMC,EAAkB,GAiBxB,SAASC,EAAc5B,GACnB,MAAM,MAAE6B,GAAU7B,EAClB,GAAKuB,EAIL,OADAF,EAAIS,MAAM,2BAA4B9B,GAC9B6B,GACJ,KAAKpJ,EAAYsJ,SACbX,EAAahE,KAAK4C,EAAQ6B,MAAO7B,GACjCoB,EAAahE,KAAK4C,EAAQlD,KAAMkD,EAAQgC,SACxC,MACJ,QACIX,EAAIY,IAAI,iCAAkCjC,EAAQ6B,QAG9D,SAASK,EAAYlC,EAASmC,GAAa,GACvC,OAAOnJ,EAAUoC,UAAM,OAAQ,GAAQ,YACnC,IAAKmG,EACD,MAAM7I,EAAS0J,OAAOC,WAAW,gCAErC,GAAIF,EAAY,CACZT,IACAC,EAAgBD,GAAchJ,EAAS4J,iBAEvC,aADuBf,EAAMK,cAAcvJ,OAAOkK,OAAOlK,OAAOkK,OAAO,GAAIvC,GAAU,CAAEwC,GAAI,GAAGd,KAGlGH,EAAMK,cAAc5B,MAG5B,MAsCMyC,EAAiB3J,EAA8B,QAAE,CACnDsI,eACAjG,KAxCUuH,GAAa1J,OAAU,OAAQ,OAAQ,GAAQ,YACzDwI,EAAYnJ,OAAOkK,OAAOlK,OAAOkK,OAAOlK,OAAOkK,OAAO,GAAIf,GAAYkB,GAAW,CAAEC,IAAK,iBACxFlK,EAAYmK,YAAYF,EAASZ,OACjCT,EAAIS,MAAM,QACV,IAGI,OAFAP,QAAc9I,EAAYoK,SAASrB,EAAWzI,EAAuC,SAC3E,OAAVwI,QAA4B,IAAVA,GAA4BA,EAAMtF,GAAGxD,EAAYqK,WAAYlB,IACxE,EAEX,MAAO9B,GAEH,OADAuB,EAAIvB,MAAMrH,EAAYsK,mBAAmBjD,KAClC,MA8BXpF,KA3BUsI,GAAWhK,OAAU,OAAQ,OAAQ,GAAQ,YACvD,IAAIiK,EAAIC,EACR7B,EAAIS,MAAM,SAAUkB,GACpB,IACI,MAAMG,QAAiBjB,EAAY,CAAEL,MAAOpJ,EAAY2K,OAAOC,KAAMvG,KAAMrE,EAAY2K,OAAOC,KAAMrB,QAASgB,IAC7G,OAAIG,GACA9B,EAAIS,MAAM,aAAcqB,GACnBA,EAASG,WACuB,QAA3BL,EAAKE,EAASnB,eAA4B,IAAPiB,OAAgB,EAASA,EAAGM,QAAU7K,EAAS8K,kBAAkBC,oBACtGvB,EAAYzJ,EAAYiL,gBAAgBjL,EAAYkL,WAAWC,uBAAuB,IAEzD,QAA3BV,EAAKC,EAASnB,eAA4B,IAAPkB,OAAgB,EAASA,EAAGK,QAAU7K,EAAS8K,kBAAkBK,kBACtG3B,EAAYzJ,EAAYiL,gBAAgBjL,EAAYkL,WAAWG,sBAAsB,IAGtFX,GAEJ1K,EAAYsK,mBAAmBrK,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBO,wBAEhG,MAAOjE,GAEH,OADAuB,EAAIvB,MAAM,iBAAkBA,GACrBrH,EAAYsK,mBAAmBjD,OAO1CkE,OA5EYC,SACE7H,IAAVmF,GAEJA,EAAMK,cAAc,CAAEC,MAAOpJ,EAAY2K,OAAOc,OAAQpH,KAAMrE,EAAY2K,OAAOc,OAAQlC,QAAS,CAAEiC,gBA0EpGE,QAxFY,KACZ/C,EAAaL,qBACbS,EAAY/I,EAAYgJ,wBAuFxB2C,WArFgBjB,IAChB,IAAK5B,EACD,MAAM7I,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBa,gBAEhE,MAAM,KAAEvH,EAAI,QAAEkF,GAAYmB,EAC1B5B,EAAMK,cAAc,CAAEC,MAAOpJ,EAAYsJ,SAAUjF,OAAMkF,eAmF7DzJ,EAAiB,QAAIkK,EACrBlK,EAAQoJ,gBAAkBA,G,kCCnmB1B,IAAI2C,EAAc,EAAQ,IACtBC,EAAS,EAAQ,IACjBC,EAAoB,EAAQ,MAC5BC,EAAa,EAAQ,MACrBC,EAAY,EAAQ,MACpBhM,EAAW,EAAQ,KACnBiM,EAAa,EAAQ,MAEzB,SAAS/L,EAAuBC,GAAK,OAAOA,GAAkB,kBAANA,GAAkB,YAAaA,EAAIA,EAAI,CAAE,QAAWA,GAE5G,IAAI+L,EAAmChM,EAAsB6L,GACzDI,EAAkCjM,EAAsB8L,GACxDI,EAAmClM,EAAsB+L,GAiB7D,SAAS3L,EAAUC,EAASC,EAAYC,EAAGC,GAEvC,OAAO,IAAKD,IAAMA,EAAIE,WAAU,SAAUC,EAASC,GAC/C,SAASC,EAAUhB,GAAS,IAAMiB,EAAKL,EAAUM,KAAKlB,IAAW,MAAOK,GAAKU,EAAOV,IACpF,SAASc,EAASnB,GAAS,IAAMiB,EAAKL,EAAiB,MAAEZ,IAAW,MAAOK,GAAKU,EAAOV,IACvF,SAASY,EAAKG,GAJlB,IAAepB,EAIaoB,EAAOC,KAAOP,EAAQM,EAAOpB,QAJ1CA,EAIyDoB,EAAOpB,MAJhDA,aAAiBW,EAAIX,EAAQ,IAAIW,GAAE,SAAUG,GAAWA,EAAQd,OAITsB,KAAKN,EAAWG,GAClGF,GAAML,EAAYA,EAAUW,MAAMd,EAASC,GAAc,KAAKQ,WAItE,MAkBMqL,EAeA,CACEC,QAAS,CAACC,EAAIC,KACV,MAAMF,EAAUG,WAAWF,EAAIC,GAC/B,MAAO,IAAME,aAAaJ,KAIhCK,EAAiB,CAACC,EAAYJ,EAAK,MAAS,IAAI7L,QAAQ,CAACC,EAASC,KACpE,IAAIM,GAAO,EACX,MAAM0L,EAAeD,EAAWE,cAAcrH,IAE1C,GAAc,cAAVA,EAAuB,CACvB,GAAItE,EACA,OACJuL,IACAvL,GAAO,EACP0L,EAAaE,SACbnM,OAEL,GACG8L,EAAeL,EAAMC,QAAQ,KAC3BnL,IAEJ0L,EAAaE,SACblM,EAAOb,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBC,uBAC9DyB,KAiBDQ,EAAiB,CACnBC,QAAS,CACL,uCAAsB,CAClBC,YAJe,uCAKfC,UAAW,uCACXC,WAAY,0CAIlBC,EAAoB,GAC1B,IAAK,MAAMC,KAAc3N,OAAO4I,KAAKyE,GAAiB,CAClD,MAAMO,EAAWP,EAAeM,GAChCD,EAAkBzI,QAAQjF,OAAO4I,KAAKgF,IAE1C,MAAMC,EAA2B,IAAMH,EACjCI,EAAyB,CAACP,EAAaI,KACzC,MAAMC,EAAWP,EAAeM,GAChC,IAAKC,EACD,OAAO,KAEX,MAAMG,EAAUH,EAASL,GACzB,OAAKQ,GACM,MAiBf,MAAMC,EACF,YAAYC,EAAQC,EAAqBC,GACrCpL,KAAKqL,QAAU,GACfrL,KAAKoH,GAAK8D,EAAO9D,GACjBpH,KAAKkL,OAASA,EACdlL,KAAKmL,oBAAsBA,EAC3BnL,KAAKoL,qBAAuBA,GAKpC,MAAM,MAAEE,EAAK,aAAEC,EAAY,WAAEC,EAAU,eAAEC,GAAmBhC,EAA4B,QAClFiC,EAAiB,GACvB,IAAIC,EAAiB,CACjBC,WAAY,IACZhC,QAAS,KA+WbiC,EAAO1O,QApWP,MACI,YAAY2O,GACR,IAAIjE,EACJ7H,KAAK+L,YAAa,EAClB/L,KAAKgM,SAAU,EACfhM,KAAKiM,YAAc,IACnBjM,KAAKkM,WAAa,KAClBlM,KAAKiM,YAA6C,QAA9BpE,EAAKiE,EAAQG,mBAAgC,IAAPpE,EAAgBA,EAAK,IAEnF,QACA,UAAUsE,GACN,MAAMC,EAAWX,EAAeU,GAChCnM,KAAK+L,YAAa,EAClB/L,KAAKqM,UAAYD,EAErB,UAEA,gBACI,OAAIpM,KAAKsM,gBAETtM,KAAKsM,cAAgB,IAAIlD,EAAkBG,WA/J/CG,EAA6B,QAAE6C,MAAM,CAAEC,WAAW,KA8JnCvO,QAAQC,QAAQ8B,KAAKsM,eAKpC,YACI,OAAO1O,EAAUoC,UAAM,OAAQ,GAAQ,YACnC,OAAO,IAAI/B,QAAQ,CAACC,EAASC,IAAWP,EAAUoC,UAAM,OAAQ,GAAQ,YACpE,MAAMyM,EAAa,GACbH,QAAsBtM,KAAK0M,gBACjC,UACUzC,EAAeqC,GAEzB,MAAO5H,GAGH,YADAvG,EAAOuG,GA3KG,IAACiI,EA8KfL,EAAcM,gBAAgB,KAAM,CAChCC,SAAUzD,EAAkB0D,SAASC,YACtC,CAACrI,EAAOwG,KACP,IAAIrD,EAAIC,EACR,GAAIpD,EAGI,CAAC0E,EAAkB4D,aAAaC,oBAAqB7D,EAAkB4D,aAAaE,yBAAyBC,SAASzI,EAAM0I,WAC5HjP,EAAOb,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBC,qBAExD3D,EAAM0I,YAAchE,EAAkB4D,aAAaK,sBACxDlP,EAAOb,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBK,mBAG7DtK,EAAOb,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBkF,aAAsC,QAAvBzF,EAAKnD,EAAM6I,cAA2B,IAAP1F,EAAgBA,EAAK,UAIxI,GApIG,EAAC1H,EAAMiH,KAC1B,IAAIS,EACJ,GAAqE,QAAhEA,EAAY,OAAPT,QAAsB,IAAPA,OAAgB,EAASA,EAAGoG,kBAA+B,IAAP3F,OAAgB,EAASA,EAAGvI,KAAK8H,EAAI,MAC9G,OAAO,EAGX,SAAIjH,IADO,sCACIsN,KAAKtN,KA8HAuN,CAAsF,QAAtE5F,EAAgB,OAAXoD,QAA8B,IAAXA,OAAoB,EAASA,EAAO/K,YAAyB,IAAP2H,EAAgBA,EAAK,KAAiB,OAAXoD,QAA8B,IAAXA,OAAoB,EAASA,EAAO9D,IAAK,CAErL,MAAM,KAAEjH,EAAI,UAAEwN,EAAS,GAAEvG,GAAkB,OAAX8D,QAA8B,IAAXA,EAAoBA,EAAS,GAEhF0C,EAAU1C,OApMHyB,EAwMO7B,IAxMUlN,OAAU,OAAQ,OAAQ,GAAQ,YAE9E,aADmC8L,EAA6B,QAAEmE,wBAAwBlB,IAC9DmB,IAAIC,IAC5B,MAAM,GAAE3G,EAAE,KAAEjH,EAAI,YAAE6N,EAAc,IAAOD,EACvC,OAAO9Q,OAAOkK,OAAO,CAAEC,KAAIjH,QAAQ6N,SAoMuBtP,KAAKuP,IACnD,IAAK,MAAM/C,KAAU+C,EAEjBL,EAAU1C,KAGlB,MAAM0C,EAAa1C,IACXuB,EAAWyB,MAAMC,GAAKA,EAAE/G,KAAO8D,EAAO9D,KACtCqF,EAAWvK,KAAKgJ,IAGxBvB,EAAMC,QAAQ,KACV0C,EAAc8B,iBACdlQ,EAAQuO,IACTzM,KAAKiM,oBAIpB,QAAQoC,GACJ,IAAIxG,EAAIC,EACR,OAAOlK,EAAUoC,UAAM,OAAQ,GAAQ,YACnC,MAAM,KAAEsO,GAASD,EACjB,IAAKC,EACD,MAAMhR,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBmG,iBAEhE,IAAIrD,EAAS,KACTQ,EAAe4C,WAETtO,KAAKwO,QAAQF,IAEvB,MAAMhC,QAAsBtM,KAAK0M,gBACjC,UACUzC,EAAeqC,GAEzB,MAAO5H,GAEH,MAAMA,EAEV,IAAKwG,EAAQ,CACT,MAAM+C,QAAgB3B,EAAc2B,QAAQ,CAACK,KAC5CpD,GAAU+C,EAEf,IAAK/C,EAAQ,CACT,MACMuD,SADwBnC,EAAcoC,iBAAiB5D,MACxB6D,OAAOzD,GAAUA,EAAO9D,KAAOkH,IAEnEpD,GAAUuD,EAEf,IAAKvD,EAED,IACIA,QAAeoB,EAAcsC,gBAAgBN,EAAM3C,GAEvD,MAAOlO,GAEH,GAAIA,EAAE2P,YAAchE,EAAkB4D,aAAa6B,uBAC/CpR,EAAE2P,YAAchE,EAAkB4D,aAAa8B,mBAK/C,MAAMxR,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB2G,kBAAuC,QAAnBlH,EAAKpK,EAAE8P,cAA2B,IAAP1F,EAAgBA,EAAKpK,GAJhIkO,EAAiB,GACjBT,QAAeoB,EAAcsC,gBAAgBN,GAOzD,IAAKpD,EACD,MAAM5N,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB2G,kBAAmB,+BAEnF,WAAY7D,EAAO8D,eAEf,UACU9D,EAAO+D,QAAQtD,GAEzB,MAAOlO,GAEH,GAAIA,EAAE2P,YAAchE,EAAkB4D,aAAa6B,uBAC/CpR,EAAE2P,YAAchE,EAAkB4D,aAAa8B,mBAK/C,MAAMxR,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB2G,kBAAuC,QAAnBjH,EAAKrK,EAAE8P,cAA2B,IAAPzF,EAAgBA,EAAKrK,GAJhIkO,EAAiB,SACXT,EAAO+D,UAOzB,GAAgC,YAA5B/F,EAAYgG,SAASC,GAAkB,CAGvC,aAzRevR,OAAU,OAAQ,OAAQ,GAAQ,YAE7D,aAD0B8L,EAA6B,QAAE0F,wBACtCtB,IAAIC,IACnB,MAAM,GAAE3G,EAAE,KAAEjH,EAAI,YAAE6N,EAAc,IAAOD,EACvC,OAAO9Q,OAAOkK,OAAO,CAAEC,KAAIjH,QAAQ6N,SAoROqB,KAAKC,GAAgBA,EAAalI,MAAmB,OAAX8D,QAA8B,IAAXA,OAAoB,EAASA,EAAO9D,KAE/H,MAAM9J,EAAS0J,OAAOC,WAAW,8BAGnCiE,EAAOqE,wCACb,IACIC,EADAC,EArKc,CAACvE,IAC3B,IAAKA,IAAWA,EAAOwE,aACnB,OAAO,KACX,MAAOC,GAAezE,EAAOwE,aACvBD,EAAQ1E,EAAuB4E,EAAa,WAClD,OAAKF,GACM,MA+JSG,CAAsB1E,GAElC,IAAKuE,EACD,IAAK,MAAMjF,KAAeM,IACtB,IACI0E,QAAwBtE,EAAO2E,0BAA0BrF,GACzDiF,EAAQ1E,EAAuBP,EAAa,WAC5C,MAEJ,MAAO/M,IAKf,IAAKgS,EACD,MAAMnS,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB0H,oBAEhE,MAAM,YAAEtF,EAAW,UAAEC,EAAS,WAAEC,GAAe+E,EAI/C,GAHKD,IACDA,QAAwBtE,EAAO2E,0BAA0BrF,KAExDgF,EACD,MAAMlS,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB2H,2BAEhE,IAAI5E,EACAC,EACJ,IAAK,MAAM4E,KAAKR,EACRQ,EAAE1B,OAAS7D,EACXU,EAAsB6E,EAEjBA,EAAE1B,OAAS5D,IAChBU,EAAuB4E,GAG/B,IAAK7E,EACD,MAAM7N,EAAS0J,OAAOC,WAAW,6DAErC,IAAKmE,EACD,MAAM9N,EAAS0J,OAAOC,WAAW,8DAErC,IAAKkE,EAAoB8E,uBACrB,MAAM3S,EAAS0J,OAAOC,WAAW,mEAErC,IAAKmE,EAAqB8E,aACtB,MAAM5S,EAAS0J,OAAOC,WAAW,wEAErC,MAAMqC,EAAY,IAAI2B,EAAaC,EAAQC,EAAqBC,GAChE9B,EAAU6G,mBAAqBnQ,KAAKoQ,uBAAuB9G,EAAU8B,sBACrEM,EAAe4C,GAAQhF,EACvB,MAAM+G,EAAyBnF,EAAOoF,eAAe,KAEjDtQ,KAAKwO,QAAQF,GACc,OAA3B+B,QAA8D,IAA3BA,GAA6CA,EAAuBhG,WAE3G,MAAO,CAAEiE,WAGjB,uBAAuBiC,GACnB,IAAIC,EAAe,EACfC,EAAW,GACf,MAAMtG,EAAeoG,EAAeG,QAAQ,CAAChM,EAAOsL,KAChD,IAAInI,EAAIC,EAAI6I,EACZ,GAAIjM,EAEI1E,KAAKkM,YACLlM,KAAKkM,WAAW/N,OAAOb,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBwI,6BAAsD,QAAvB/I,EAAKnD,EAAM6I,cAA2B,IAAP1F,EAAgBA,EAAKnD,EAAME,cAH9K,CAQA,IAAKoL,EACD,MAAM1S,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkByI,iBAEhE,IACI,MAAMC,EAAO3H,EAAO4H,OAAOC,KAAKhB,EAAE5S,MAAO,UAQzC,GApRM,CAAC6T,IACnB,GAAIA,EAAM9O,OAAS,EACf,OAAO,EACX,MAAO+O,EAAmBC,EAAQC,GAAUH,EAC5C,OAAI1O,OAAO8O,aAAaH,KAAuB3O,OAAO8O,aAAa/H,EAAUgI,mBACzE/O,OAAO8O,aAAaF,KAAY5O,OAAO8O,aAAa/H,EAAUiI,sBAC9DhP,OAAO8O,aAAaD,KAAY7O,OAAO8O,aAAa/H,EAAUiI,sBAuQlDC,CAAcV,IACdN,EAAeM,EAAKW,YAAY,GAChChB,EAAW,IAAIK,EAAKY,SAAS,KAG7BjB,EAAWA,EAAS/Q,OAAO,IAAIoR,IAE/BL,EAAStO,OAASmH,EAAUqI,oBAAsBnB,EAAc,CAChE,MAAMpT,EAAQ+L,EAAO4H,OAAOC,KAAKP,GACjCD,EAAe,EACfC,EAAW,GACgB,QAA1B3I,EAAK9H,KAAKkM,kBAA+B,IAAPpE,GAAyBA,EAAG5J,QAAQd,EAAMwU,SAAS,SAG9F,MAAOlN,GAEwB,QAA1BiM,EAAK3Q,KAAKkM,kBAA+B,IAAPyE,GAAyBA,EAAGxS,OAAOuG,OAG9E,MAAO,KAEHyF,EAAaE,UAGrB,QAAQiE,GACJ,IAAIzG,EAAIC,EACR,OAAOlK,EAAUoC,UAAM,OAAQ,GAAQ,YACnC,MAAMsJ,EAAYoC,EAAe4C,GAQjC,OAPIhF,WACOoC,EAAe4C,GACkB,QAAvCzG,EAAKyB,EAAU6G,0BAAuC,IAAPtI,GAAyBA,EAAGvI,KAAKgK,GACjD,YAA5BJ,EAAYgG,SAASC,WACgB,QAA7BrH,EAAK9H,KAAKsM,qBAAkC,IAAPxE,OAAgB,EAASA,EAAG+J,uBAAuBvD,KAGjGrQ,QAAQC,SAAQ,MAG/B,KAAKoQ,EAAMnO,EAAM2Q,GACb,OAAOlT,EAAUoC,UAAM,OAAQ,GAAQ,YACnC,GAAIA,KAAKgM,QACL,OAAO/N,QAAQE,OAAOb,EAAS0J,OAAOC,WAAW,uBAErD,GAAsB,MAAlBjH,KAAKqM,UACL,MAAM/O,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB0J,wBAEhE,GAAI9R,KAAKkM,WACL,MAAM5O,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB2J,yBAEhE,MAAMzI,EAAYoC,EAAe4C,GACjC,IAAKhF,EACD,MAAMhM,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkB4J,mBAEhEhS,KAAKkM,WAAa5O,EAAS4J,iBAC3B,MAAMkF,EAAWpM,KAAKqM,UAEhB4F,EAAU1G,EAAaa,EAAUjM,EAAM2Q,GAC7C,GAAa,mBAAT3Q,EAA2B,CAC3B,MAAM+R,EAA6C,QAA5BhJ,EAAYgG,SAASC,GAhXlC,IACI,IAgXd,IAAI5J,EAAQ,EACR0L,EAAQzH,EAA6B,QAAE2I,SAASD,GACpD,KAAO3M,EAAQ0M,EAAQ9P,QAAQ,CAC3B,MAAMgH,EAAS8I,EAAQ1M,GAAO6M,WAG9B,GAFAnB,EAAMoB,OAAOlJ,GACb5D,GAAS,EACL0L,EAAMqB,SAAWJ,GAAkB3M,GAAS0M,EAAQ9P,OAAQ,CAC5D8O,EAAMsB,QAEN,UACUjJ,EAAU6B,oBAAoBqH,qBAAqBvB,EAAMW,SAAS,WACxEX,EAAQzH,EAA6B,QAAE2I,SAASD,GAEpD,MAAOzU,GAGH,YAFAuC,KAAKkM,WAAa,cAQ9B,IAAK,MAAMuG,KAAKR,EAAS,CACrB,MAAMS,EAAUD,EAAEb,SAAS,UAE3B,UACUtI,EAAU6B,oBAAoBqH,qBAAqBE,GAE7D,MAAOjV,GACH,GAAIA,EAAE2P,YAAchE,EAAkB4D,aAAa2F,mBAC/C,MAAMrV,EAAS0J,OAAOC,WAAW3J,EAAS8K,kBAAkBwK,oBAIhE,YAFA5S,KAAKkM,WAAa,OAM9B,IACI,MAAMnE,QAAiB/H,KAAKkM,WAAW2G,QACvC,GAAwB,kBAAb9K,EACP,MAAM,IAAIzF,MAAM,iCAGpB,MAAMwQ,EAAWtH,EAAWY,EAAUrE,GACtC,OAAOuD,EAAMhM,KAAKwT,GAEtB,MAAOrV,GAEH,OAAOA,EAEX,QACIuC,KAAKkM,WAAa,SAI9B,OACIlM,KAAKgM,SAAU,EAEnB,SAEQhM,KAAKkM,WACTlM,KAAKkM,WAAa,Q,60BC1gBnB,SAAS6G,EAASzE,GACvB,OAAoB,IAAhBA,EAAKnM,OAAqB,OAASmM,EAAK0E,cAAgB,+BACxC,IAAhB1E,EAAKnM,OAAqBmM,EAAK0E,cAAgB,+BAC5C1E,EAAK0E,c,+aCSP,IAAMC,EAAb,gCAsBE,WAAYC,EAAyCC,GAAkD,IAAD,ED5BjDC,EC+BnD,GAHoG,aACpG,gBACKxO,QAAUuO,EAAoBnG,EAAaqG,cAClB,kBAAnBH,EACT,EAAK9F,UAAYJ,EAAaqG,aAC9B,EAAKC,aAAe,KACpB,EAAKC,aAAe,KACpB,EAAKC,iBAAmB,KACxB,EAAKjG,OAAS2F,MACT,CACL,IAAMtO,EAAUuO,EAAoBD,EAAe9F,WAC/CxI,IACF,EAAKA,SDxC0CwO,ECwCCF,EAATtO,EDvChC6O,QAAQ,gBAAgB,SAASC,EAAG1P,GAC/C,OAAOoP,EAAOpP,IAAQ,SCwCpB,EAAKoJ,UAAY8F,EAAe9F,UAChC,EAAKkG,aAAeJ,EAAeI,aACnC,EAAKC,aAAeL,EAAeK,aACnC,EAAKC,iBAAmBN,EAAeM,iBACvC,EAAKjG,OAAS2F,EAAe3F,OAlBqE,OAoBpG,EAAKpN,KAAO,WApBwF,EAtBxG,U,MAAA,GAA8BmC,QA8CvB,SAASqR,EAAcC,EAAsBT,GAClD,IAAIU,EACEC,EAAeX,GAA4CY,EACjE,IACE,IAAMb,EAAiBc,KAAKC,MAAML,GAClCC,EAAW,IAAIZ,EAASC,EAAgBY,GACxC,MAAOI,GACPL,EAAW,IAAIZ,EAASW,EAAcE,GAExC,OAAOD,EAMF,IAAM7G,EAAe,CAM1BqG,aAAc,EAKdc,0BAA2B,EAK3BrF,mBAAoB,EAIpBsF,kBAAmB,EAInBC,qBAAsB,EAItBC,mBAAoB,EAMpBC,qBAAsB,IAKtBlH,sBAAuB,IAIvBJ,oBAAqB,IAIrBC,wBAAyB,IAIzBsH,mBAAoB,IAIpBC,2BAA4B,IAM5BC,uBAAwB,IAIxB/B,mBAAoB,IAIpBgC,qBAAsB,IAItBC,uBAAwB,IAIxBC,eAAgB,IAIhBC,mBAAoB,IAIpBjG,sBAAuB,IAMvBkG,wBAAyB,IAIzBC,gCAAiC,IAMjCC,gBAAiB,IAMjBC,sBAAuB,IAMvBC,+BAAgC,IAMhCC,0BAA2B,IAK3BC,yBAA0B,IAM1BC,iCAAkC,IAMlCC,uBAAwB,IAMxBC,6BAA8B,IAI9BC,gCAAiC,IAMjCC,2BAA4B,IAI5BC,sBAAuB,IAIvBC,qBAAsB,IAItBC,mBAAoB,IAIpBC,yBAA0B,IAI1BC,4BAA6B,IAI7BC,0BAA2B,IAM3BC,gBAAiB,IAIjBC,yBAA0B,KAOfnC,GAA+C,WAEzD/G,EAAaqG,aAAe,0EAF6B,MAGzDrG,EAAamH,0BAA4B,4BAHgB,MAIzDnH,EAAa8B,mBAAqB,2BAJuB,MAKzD9B,EAAaoH,kBAAoB,uBALwB,MAMzDpH,EAAaqH,qBAAuB,0BANqB,MAOzDrH,EAAasH,mBAAqB,uDAPuB,MAUzDtH,EAAauH,qBAAuB,6CAVqB,MAWzDvH,EAAaK,sBAAwB,+CAXoB,MAYzDL,EAAaC,oBAAsB,8BAZsB,MAazDD,EAAaE,wBAA0B,mCAbkB,MAczDF,EAAawH,mBAAqB,4BAduB,MAezDxH,EAAayH,2BAA6B,iCAfe,MAkBzDzH,EAAa0H,uBAAyB,uCAlBmB,MAmBzD1H,EAAa2F,mBAAqB,sCAnBuB,MAoBzD3F,EAAa2H,qBAAuB,0CApBqB,MAqBzD3H,EAAa4H,uBAAyB,0CArBmB,MAsBzD5H,EAAa6H,eAAiB,+BAtB2B,MAuBzD7H,EAAa8H,mBAAqB,sCAvBuB,MAwBzD9H,EAAa6B,sBAAwB,+CAxBoB,MA2BzD7B,EAAa+H,wBAA0B,mDA3BkB,MA4BzD/H,EAAagI,gCACZ,uFA7BwD,MA8BzDhI,EAAaiI,gBAAkB,yDA9B0B,MA+BzDjI,EAAakI,sBAAwB,iDA/BoB,MAkCzDlI,EAAamI,+BACZ,mFAnCwD,MAoCzDnI,EAAaoI,0BACZ,oGArCwD,MAsCzDpI,EAAaqI,yBACZ,mGAvCwD,MAwCzDrI,EAAasI,iCACZ,4GAzCwD,MA0CzDtI,EAAauI,uBAAyB,iDA1CmB,MA2CzDvI,EAAawI,6BACZ,kFA5CwD,MA6CzDxI,EAAayI,gCACZ,mGA9CwD,MAiDzDzI,EAAa0I,2BACZ,qIAlDwD,MAmDzD1I,EAAa2I,sBACZ,iIApDwD,MAqDzD3I,EAAa4I,qBACZ,gIAtDwD,MAuDzD5I,EAAa6I,mBAAqB,yCAvDuB,MAwDzD7I,EAAa8I,yBACZ,mHAzDwD,MA0DzD9I,EAAa+I,4BACZ,2FA3DwD,MA4DzD/I,EAAagJ,0BACZ,oHA7DwD,MAgEzDhJ,EAAaiJ,gBAAkB,mCAhE0B,MAiEzDjJ,EAAakJ,yBAA2B,kCAjEiB,GAwE/CC,EAAkB,CAI7BC,QAAS,EAITC,cAAe,EAIfC,iBAAkB,EAIlBC,kBAAmB,EAInBC,WAAY,EAIZC,2BAA4B,EAI5BC,oBAAqB,EAIrBC,cAAe,EAIfC,0BAA2B,EAI3BC,iBAAkB,EAIlBC,kBAAmB,GAInBC,iBAAkB,GAIlBC,8BAA+B,GAI/BC,4BAA6B,GAI7BC,cAAe,GAIfC,uBAAwB,GAIxBC,qBAAsB,GAItBC,sBAAuB,IASZC,EAAkB,CAI7BC,QAAS,EAITC,kBAAmB,EAInBnB,cAAe,EAIfoB,aAAc,EAIdC,WAAY,EAIZ5I,mBAAoB,EAIpB6I,kBAAmB,EAInBC,uBAAwB,EAIxBC,eAAgB,EAIhBC,mBAAoB,EAIpBC,iBAAkB,GAIlBC,uBAAwB,GAIxBC,cAAe,IAOJC,EAAsB,CAIjCC,YAAa,IAIbC,cAAe,IAIfC,WAAY,IAIZC,OAAQ,IAIRC,KAAM,IAINjW,MAAO,IAIPkW,WAAY,IAIZC,iBAAkB,IAIlBC,QAAS,IAITC,SAAU,IAIVC,KAAM,IAINC,WAAY,IAIZC,eAAgB,IAIhBC,eAAgB,IAIhBC,aAAc,IAIdC,UAAW,K,gDChcAnM,EAAW,CAKtBoM,eAAgB,EAMhBC,SAAU,EAMVC,SAAU,EAMVrM,WAAY,GAODsM,EAAmB,CAK9BC,WAAY,EAMZC,WAAY,EAMZC,UAAW,GA0EAC,EAAQ,CAInBlC,QAAS,UAITmC,UAAW,YAIXC,YAAa,cAIbC,aAAc,eAIdC,WAAY,aAIZC,UAAW,aAOAC,EAAW,CAItBC,KAAM,OAINC,QAAS,UAITC,MAAO,QAIPC,KAAM,OAINC,QAAS,UAIT9X,MAAO,SAOI+X,EAAqB,CAIhCjB,SAAU,EAIVkB,KAAM,EAINnB,SAAU,GC5RCoB,EAAb,WA6EE,WAAYC,EAA4BC,GAAsB,YAC5Dxd,OAAOkK,OAAOnH,KAAMwa,EAAc,CAAEE,SAAUD,IA9ElD,qDAwFE,SACEE,EACAC,GAEA,OAAO5a,KAAK0a,SAASG,mCAAmC7a,KAAKoH,GAAIuT,EAAoBC,KA5FzF,sBAqGE,SAASA,GACP,OAAO5a,KAAK0a,SAASI,kBAAkB9a,KAAKoH,GAAIwT,KAtGpD,wBA+GE,SAAWG,EAAaH,GACtB,OAAO5a,KAAK0a,SAASM,oBAAoBhb,KAAKoH,GAAI2T,EAAKH,KAhH3D,qBAyHE,SAAQ9O,GACN,OAAO9L,KAAK0a,SAAS9L,gBAAgB5O,KAAKoH,GAAI0E,KA1HlD,8BAkIE,WACE,OAAO9L,KAAK0a,SAAS7I,uBAAuB7R,KAAKoH,MAnIrD,yBA2IE,WACE,OAAOpH,KAAK0a,SAASO,kBAAkBjb,KAAKoH,MA5IhD,4BAuJE,SAAe/F,GACb,OAAOrB,KAAK0a,SAASQ,qBAAqBlb,KAAKoH,GAAI/F,KAxJvD,mDAkKE,SAAsCuZ,GACpC,OAAO5a,KAAK0a,SAASS,+CAA+Cnb,KAAKoH,GAAIwT,KAnKjF,sBA4KE,WACE,OAAO5a,KAAK0a,SAASU,kBAAkBpb,KAAKoH,MA7KhD,uCAuLE,SAA0BuI,GACxB,OAAO3P,KAAK0a,SAASW,yBAAyBrb,KAAKoH,GAAIuI,KAxL3D,mCAmME,SAAsBA,EAAmB2L,GACvC,OAAOtb,KAAK0a,SAASa,qBAAqBvb,KAAKoH,GAAIuI,EAAa2L,KApMpE,0CAiNE,SACE3L,EACA2L,EACAV,GAEA,OAAO5a,KAAK0a,SAASc,4BAA4Bxb,KAAKoH,GAAIuI,EAAa2L,EAAoBV,KAtN/F,uDAoOE,SACEjL,EACA2L,EACAG,EACAb,GAEA,OAAO5a,KAAK0a,SAASgB,yCACnB1b,KAAKoH,GACLuI,EACA2L,EACAG,EACAb,KA/ON,0DA8PE,SACEjL,EACA2L,EACAG,EACAb,GAEA,OAAO5a,KAAK0a,SAASiB,4CACnB3b,KAAKoH,GACLuI,EACA2L,EACAG,EACAb,KAzQN,6CAwRE,SACEjL,EACA2L,EACAja,EACAuZ,GAEA,OAAO5a,KAAK0a,SAASkB,+BACnB5b,KAAKoH,GACLuI,EACA2L,EACAja,EACAuZ,KAnSN,4DAkTE,UACEjL,EACA2L,EACAO,EACAjB,GAEA,OAAO5a,KAAK0a,SAASoB,wBACnB9b,KAAKoH,GACLuI,EACA2L,EACAO,EACAjB,MA7TN,0HA2UE,UACEjL,EACA2L,EACAO,EACAJ,EACAb,GAEA,OAAO5a,KAAK0a,SAASqB,yBACnB/b,KAAKoH,GACLuI,EACA2L,EACAO,EACAJ,EACAb,MAxVN,sECHaoB,EAAb,WA+BE,WAAYC,EAA8BxB,GAAsB,YAC9Dxd,OAAOkK,OAAOnH,KAAMic,EAAe,CAAEvB,SAAUD,IAhCnD,2CAyCE,WACE,OAAOza,KAAK0a,SAASwB,2BAA2Blc,KAAKoH,MA1CzD,0CAoDE,SAA6BkU,GAC3B,OAAOtb,KAAK0a,SAASyB,uBAAuBnc,KAAKoH,GAAIkU,KArDzD,gCAiEE,SAAmBA,EAA0BV,GAC3C,OAAO5a,KAAK0a,SAAS0B,8BAA8Bpc,KAAKoH,GAAIkU,EAAoBV,KAlEpF,6CA+EE,SACEU,EACAG,EACAb,GAEA,OAAO5a,KAAK0a,SAAS2B,2CACnBrc,KAAKoH,GACLkU,EACAG,EACAb,KAxFN,gDAsGE,SACEU,EACAG,EACAb,GAEA,OAAO5a,KAAK0a,SAAS4B,8CACnBtc,KAAKoH,GACLkU,EACAG,EACAb,KA/GN,mCA6HE,SACEU,EACAja,EACAuZ,GAEA,OAAO5a,KAAK0a,SAAS6B,iCAAiCvc,KAAKoH,GAAIkU,EAAoBja,EAAUuZ,KAlIjG,mEA+IE,UACEU,EACAO,EACAjB,GAEA,OAAO5a,KAAK0a,SAAS8B,0BAA0Bxc,KAAKoH,GAAIkU,EAAoBO,EAAgBjB,MApJhG,+HAgKE,UACEU,EACAO,EACAJ,EACAb,GAEA,OAAO5a,KAAK0a,SAAS+B,2BACnBzc,KAAKoH,GACLkU,EACAO,EACAJ,EACAb,MA3KN,oECHa8B,EAAb,WA6CE,WAAYC,EAAoClC,GAAsB,YACpExd,OAAOkK,OAAOnH,KAAM2c,EAAkB,CAAEjC,SAAUD,IA9CtD,sDAyDE,UAAWG,GACT,OAAO5a,KAAK0a,SAASkC,gBAAgB5c,KAAKoH,GAAIwT,MA1DlD,gGAoEE,UAAYa,EAAqBb,GAC/B,OAAO5a,KAAK0a,SAASmC,iBAAiB7c,KAAKoH,GAAIqU,EAAab,MArEhE,gECEakC,EAAb,WA6DE,WAAYC,EAA4CtC,GAAsB,YAC5Exd,OAAOkK,OAAOnH,KAAM+c,EAAsB,CAAErC,SAAUD,IA9D1D,uCAuEE,WACE,OAAOza,KAAK0a,SAASsC,8BAA8Bhd,KAAKoH,MAxE5D,kBAmFE,SAAKwT,GACH,OAAO5a,KAAK0a,SAASuC,oBAAoBjd,KAAKoH,GAAIwT,KApFtD,+BAgGE,SAAkBa,EAAqBb,GACrC,OAAO5a,KAAK0a,SAASwC,iCAAiCld,KAAKoH,GAAIqU,EAAab,KAjGhF,kCA6GE,SAAqBa,EAAqBb,GACxC,OAAO5a,KAAK0a,SAASyC,oCAAoCnd,KAAKoH,GAAIqU,EAAab,KA9GnF,qBA0HE,SACEvZ,EACAuZ,GAEA,OAAO5a,KAAK0a,SAAStK,uBAAuBpQ,KAAKoH,GAAI/F,EAAUuZ,KA9HnE,kDA0IE,UAAqBiB,EAAsBjB,GACzC,OAAO5a,KAAK0a,SAAS0C,iCAAiCpd,KAAKoH,GAAIyU,EAAgBjB,MA3InF,4GAsJE,UAAsBiB,EAAsBJ,EAAqBb,GAC/D,OAAO5a,KAAK0a,SAAS2C,kCAAkCrd,KAAKoH,GAAIyU,EAAgBJ,EAAab,MAvJjG,kE,kBC6yBa0C,EAAgCC,IAAcC,iBAC9C1d,EAAe2d,IC7wBflU,EAAb,WAkBE,aAA8C,IAAD,OAAjCuC,EAAiC,uDAAJ,GAAI,YAC3C9L,KAAK0d,cAAgB,IAAI5d,EAAawd,GACtCtd,KAAK2d,UAAY,EACjB3d,KAAK4d,gBAAkB,GACvB5d,KAAK6d,qBAAuB,GAE5B,IAAMC,EAAuBhS,EAAQgS,qBACT,MAAxBA,GAAkE,MAAlChS,EAAQiS,yBAC1C/d,KAAK6d,qBAAqB7d,KAAKge,iBAAmBhe,KAAK0d,cAAc1Y,YACnEsY,EAAUW,mBACV,SAACC,GAKCJ,EAJ2B,MAAvBI,EAIiB,CACnBC,qBAAsBD,EAAoBC,qBAAqBrQ,KAC7D,SAAA0M,GAAY,OAAI,IAAID,EAAOC,EAAc,OALtB,UAY7Bxa,KAAKoe,6BAA+BtS,EAAQuS,4BACxCvS,EAAQuS,4BACRtK,EAEJuJ,EAAUgB,aAAaxS,EAAQiS,wBAA0B,MA9C7D,4CAqDE,WACE,IAAMQ,EAAiB,IAAItL,EACzB,CACE7F,UAAWJ,EAAamH,0BACxBb,aAAe,KACfC,aAAe,KACfC,iBAAmB,KACnBjG,OAAS,MAEXvN,KAAKoe,8BAEP,IAAK,IAAMhX,KAAMpH,KAAK4d,gBACpB5d,KAAK4d,gBAAgBxW,GAAImX,KAjE/B,mCAyEE,WACE,IAAK,IAAMnX,KAAMpH,KAAK6d,qBACpB7d,KAAK6d,qBAAqBzW,GAAIiD,WA3EpC,qBAoFE,WAEEiT,EAAUkB,gBAGyB,MAA/Bxe,KAAKye,yBACPze,KAAKye,uBAAuBpU,SAC5BrK,KAAKye,uBAAyB,MAEhCze,KAAK0e,wBAGL1e,KAAK2e,qBAhGT,2BAyGE,WAEE,OADA3e,KAAK2d,WAAa,EACX3d,KAAK2d,UAAU/L,aA3G1B,gDAqHE,UAAsBiB,GAAkC,IAAD,OAC/CzL,EAAKpH,KAAKge,gBAChB,IACE,IAAMY,EAAiB,IAAI3gB,SAAQ,SAACC,EAASC,GAC3C,EAAKyf,gBAAgBxW,GAAMjJ,KAEvBf,QAAca,QAAQ4gB,KAAK,CAACD,EAAgB/L,IAElD,cADO7S,KAAK4d,gBAAgBxW,GACrBhK,EACP,MAAOsH,GAEP,aADO1E,KAAK4d,gBAAgBxW,GACtBuM,EAAcjP,EAAME,QAAS5E,KAAKoe,kCAhI9C,gFA0IE,SAAYU,GACVxB,EAAUyB,YAAYD,KA3I1B,sBAkJE,WACE,OAAO9e,KAAKgf,aAAa1B,EAAUwB,cAnJvC,+BA8KE,SAAkBlE,GAChB0C,EAAU2B,kBAAkBrE,KA/KhC,0CA0LE,UAAaA,GAKX,OAJKA,IACHA,EAAgB5a,KAAKge,uBAEjBhe,KAAKgf,aAAa1B,EAAU4B,OAAOtE,IAClC5a,QA/LX,kGAwME,UAAc4a,GAKZ,OAJKA,IACHA,EAAgB5a,KAAKge,uBAEjBhe,KAAKgf,aAAa1B,EAAU6B,QAAQvE,IACnC5a,QA7MX,0EAsNE,WACE,OAAOA,KAAKgf,aAAa1B,EAAUva,WAvNvC,2BA2OE,SAAc1B,GAAqG,IAG7G+d,EAH4G,OAAjDC,EAAiD,wDAC1GlV,EAA6BnK,KAAK0d,cAAc1Y,YAAYsY,EAAUgC,iBAAkBje,GACxF+F,EAAKpH,KAAKge,gBAGhB,GAAIqB,EAAkB,CACpB,IAAIE,GAAY,EAChBvf,KAAKgf,aAAahf,KAAK+C,SAASrE,MAAK,SAAA8gB,GAC9BD,GACHle,EAASme,MAIbJ,EAAsB,CACpB/U,OAAQ,WAC+B,MAAjC,EAAKwT,qBAAqBzW,KAC5BmY,GAAY,SACL,EAAK1B,qBAAqBzW,GACjC+C,EAAaE,iBAKnB+U,EAAsB,CACpB/U,OAAQ,WAC+B,MAAjC,EAAKwT,qBAAqBzW,YACrB,EAAKyW,qBAAqBzW,GACjC+C,EAAaE,YAOrB,OADArK,KAAK6d,qBAAqBzW,GAAMgY,EACzBA,IA7QX,6BA6RE,SACEK,EACA3T,EACAzK,GACC,IAAD,OACArB,KAAKoO,iBAQLpO,KAAKye,uBAAyBze,KAAK0d,cAAc1Y,YAAYsY,EAAUoC,WAPlD,SAAC,GAAqD,IAAD,WAAnDhb,EAAmD,KAA5C8V,EAA4C,KACxEnZ,EACEqD,EAAQiP,EAAcjP,EAAO,EAAK0Z,8BAAgC,KAClE5D,EAAe,IAAID,EAAOC,EAAc,GAAQ,SAKpD8C,EAAU1Q,gBAAgB6S,EAAO3T,KA3SrC,4BAiTE,WACqC,MAA/B9L,KAAKye,yBACPze,KAAKye,uBAAuBpU,SAC5BrK,KAAKye,uBAAyB,MAEhCnB,EAAUlP,mBAtTd,sEAkUE,UACEuR,EACAhF,EACAC,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMxD,QAAqBxa,KAAKgf,aAC9B1B,EAAUzC,mCAAmC8E,EAAkBhF,EAAoBC,IAErF,OAAO,IAAIL,EAAOC,EAAcxa,SA7UpC,gHAuVE,UAAwB2f,EAA4B/E,GAC7CA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMxD,QAAqBxa,KAAKgf,aAAa1B,EAAUxC,kBAAkB6E,EAAkB/E,IAC3F,OAAO,IAAIL,EAAOC,EAAcxa,SA5VpC,gHAuWE,UAA0B2f,EAA4B5E,EAAaH,GAC5DA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMxD,QAAqBxa,KAAKgf,aAAa1B,EAAUtC,oBAAoB2E,EAAkB5E,EAAKH,IAClG,OAAO,IAAIL,EAAOC,EAAcxa,SA5WpC,sGAsXE,UAAc4f,GAA6D,IAAD,OAExE,aAD4B5f,KAAKgf,aAAa1B,EAAUrP,QAAQ2R,KAC3C9R,KAAI,SAAC0M,GACxB,OAAO,IAAID,EAAOC,EAAc,SAzXtC,2GAoYE,UAAuB9K,GAAoD,IAAD,OAExE,aAD4B1P,KAAKgf,aAAa1B,EAAU5O,iBAAiBgB,KACpD5B,KAAI,SAAC0M,GACxB,OAAO,IAAID,EAAOC,EAAc,SAvYtC,0GAoZE,UAAsBmF,EAA4B7T,GAChD,IAAM0O,QAAqBxa,KAAKgf,aAAa1B,EAAU1O,gBAAgB+Q,EAAkB7T,IACzF,OAAO,IAAIyO,EAAOC,EAAcxa,SAtZpC,mHA+ZE,UAA6B2f,GAC3B,IAAMnF,QAAqBxa,KAAKgf,aAAa1B,EAAUzL,uBAAuB8N,IAC9E,OAAO,IAAIpF,EAAOC,EAAcxa,SAjapC,yFA6aE,SAAqB2f,EAA4Bte,GAAqE,IAAD,OAM7G8I,EAA6BnK,KAAK0d,cAAc1Y,YACpDsY,EAAUuC,oBANkB,SAAC,GAAoD,IAAD,WAAlDnb,EAAkD,KAA3C8V,EAA2C,KAC5EmF,IAAqBnF,EAAapT,IACtC/F,EAASqD,EAAQiP,EAAcjP,EAAO,EAAK0Z,8BAAgC,KAAM,IAAI7D,EAAOC,EAAc,OAQtGpT,EAAKpH,KAAKge,gBACVoB,EAAsB,CAC1B/U,OAAQ,WAC+B,MAAjC,EAAKwT,qBAAqBzW,YACrB,EAAKyW,qBAAqBzW,GACjC+C,EAAaE,YAKnB,OADArK,KAAK6d,qBAAqBzW,GAAMgY,EACzBA,IAlcX,+BA2cE,SAAkBO,GAChB,OAAO3f,KAAKgf,aAAa1B,EAAUrC,kBAAkB0E,MA5czD,kFAydE,UACEA,EACA/E,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMxD,QAAqBxa,KAAKgf,aAC9B1B,EAAUnC,+CAA+CwE,EAAkB/E,IAE7E,OAAO,IAAIL,EAAOC,EAAcxa,SAnepC,8GA+eE,UAAwB2f,GAAsD,IAAD,OAE3E,aADuB3f,KAAKgf,aAAa1B,EAAUlC,kBAAkBuE,KACrD7R,KAAI,SAAAmO,GAClB,OAAO,IAAID,EAAQC,EAAe,SAlfxC,6FA8fE,SAAyB0D,EAA4BhQ,GACnD,OAAO3P,KAAK8f,uBAAuBxC,EAAUjC,yBAAyBsE,EAAkBhQ,MA/f5F,wCA0gBE,SAA2BoQ,GACzB,OAAO/f,KAAK8f,uBAAuBxC,EAAUzN,0BAA0BkQ,MA3gB3E,0DAshBE,UACEC,GACiC,IAAD,OAEhC,aAD8BhgB,KAAKgf,aAAagB,IACzBlS,KAAI,SAAAiP,GACzB,OAAO,IAAID,EAAeC,EAAsB,SA3hBtD,yFAwiBE,SACE4C,EACAhQ,EACA2L,GAEA,OAAOtb,KAAKigB,mBAAmB3C,EAAU/B,qBAAqBoE,EAAkBhQ,EAAa2L,MA7iBjG,oCAyjBE,SAAuByE,EAA+BzE,GACpD,OAAOtb,KAAKigB,mBAAmB3C,EAAU4C,sBAAsBH,EAAmBzE,MA1jBtF,2CAqkBE,SAA8B6E,GAC5B,OAAOngB,KAAKigB,mBAAmB3C,EAAU8C,6BAA6BD,MAtkB1E,sDAglBE,UAAyBE,GAAmF,IAAD,OAEzG,aAD0BrgB,KAAKgf,aAAaqB,IACzBvS,KAAI,SAAA6O,GACrB,OAAO,IAAID,EAAWC,EAAkB,SAnlB9C,sHAomBE,UACEgD,EACAhQ,EACA2L,EACAV,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAU9B,4BAA4BmE,EAAkBhQ,EAAa2L,EAAoBV,IAE3F,OAAO,IAAIkC,EAAeC,EAAsB/c,SAhnBpD,8HA8nBE,UACE+f,EACAzE,EACAV,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUgD,6BAA6BP,EAAmBzE,EAAoBV,IAEhF,OAAO,IAAIkC,EAAeC,EAAsB/c,SAzoBpD,kHAspBE,UACEmgB,EACAvF,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUiD,mBAAmBJ,EAA0BvF,IAEzD,OAAO,IAAIkC,EAAeC,EAAsB/c,SAhqBpD,qIA+qBE,UACE2f,EACAhQ,EACA2L,EACAkF,EACA5F,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUmD,6BACRd,EACAhQ,EACA2L,EACAkF,GACA,EACA5F,IAGJ,OAAO,IAAIkC,EAAeC,EAAsB/c,SAnsBpD,6IAktBE,UACE+f,EACAzE,EACAkF,EACA5F,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUoD,8BAA8BX,EAAmBzE,EAAoBkF,GAAa,EAAM5F,IAEpG,OAAO,IAAIkC,EAAeC,EAAsB/c,SA9tBpD,iIA4uBE,UACEmgB,EACAK,EACA5F,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUnS,oBAAoBgV,EAA0BK,GAAa,EAAM5F,IAE7E,OAAO,IAAIkC,EAAeC,EAAsB/c,SAvvBpD,0IAswBE,UACE2f,EACAhQ,EACA2L,EACAkF,EACA5F,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUmD,6BACRd,EACAhQ,EACA2L,EACAkF,GACA,EACA5F,IAGJ,OAAO,IAAIkC,EAAeC,EAAsB/c,SA1xBpD,gJAyyBE,UACE+f,EACAzE,EACAkF,EACA5F,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUoD,8BAA8BX,EAAmBzE,EAAoBkF,GAAa,EAAO5F,IAErG,OAAO,IAAIkC,EAAeC,EAAsB/c,SArzBpD,oIAm0BE,UACEmgB,EACAK,EACA5F,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMjB,QAA6B/c,KAAKgf,aACtC1B,EAAUnS,oBAAoBgV,EAA0BK,GAAa,EAAO5F,IAE9E,OAAO,IAAIkC,EAAeC,EAAsB/c,SA90BpD,uGA81BE,SACE2f,EACAhQ,EACA2L,EACAja,EACAuZ,GAEA,IAAM+F,EAAsB/F,GAAiB5a,KAAKge,gBAClD,OAAOhe,KAAK4gB,6BACVtD,EAAU1B,+BAA+B+D,EAAkBhQ,EAAa2L,EAAoBqF,GAC5FA,EACAtf,KAz2BN,8CA03BE,SACE0e,EACAzE,EACAja,EACAuZ,GAEA,IAAM+F,EAAsB/F,GAAiB5a,KAAKge,gBAClD,OAAOhe,KAAK4gB,6BACVtD,EAAUuD,gCAAgCd,EAAmBzE,EAAoBqF,GACjFA,EACAtf,KAp4BN,oCAo5BE,SACE8e,EACA9e,EACAuZ,GAEA,IAAM+F,EAAsB/F,GAAiB5a,KAAKge,gBAClD,OAAOhe,KAAK4gB,6BACVtD,EAAUwD,sBAAsBX,EAA0BQ,GAC1DA,EACAtf,KA75BN,0CA26BE,SACE0f,EACAnG,EACAvZ,GACe,IAAD,OAcR8I,EAA6BnK,KAAK0d,cAAc1Y,YAAYsY,EAAU0D,WAbpD,SAAC,GAIlB,IAAD,WAJoBtc,EAIpB,KAJ2B6L,EAI3B,KAJ2C0Q,EAI3C,KACArG,IAAkBqG,IAClBvc,EACFrD,EAASsS,EAAcjP,EAAO,EAAK0Z,8BAA+B,MAGpE/c,EAAS,KAAM,IAAIyb,EAAevM,EAAgB,QAK9CnJ,EAAKpH,KAAKge,gBACVoB,EAAoC,CACxC/U,OAAQ,WAC+B,MAAjC,EAAKwT,qBAAqBzW,YACrB,EAAKyW,qBAAqBzW,GACjC+C,EAAaE,YAgBnB,OAZArK,KAAK6d,qBAAqBzW,GAAMgY,EAEhCpf,KAAKgf,aAAa+B,GAAgBriB,MAChC,WACE0gB,EAAoB/U,YAEtB,SAAC3F,GACCrD,EAASqD,EAAO,MAChB0a,EAAoB/U,YAIjB,CACLA,OAAQ,WACNiT,EAAU2B,kBAAkBrE,OAt9BpC,2DAy+BE,UACE+E,EACAhQ,EACA2L,EACAO,EACAjB,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAUxB,wBACR6D,EACAhQ,EACA2L,EACAO,EACAjB,IAGJ,OAAO,IAAI8B,EAAWC,EAAkB3c,SA5/B5C,4HA2gCE,UACE+f,EACAzE,EACAO,EACAjB,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAU4D,yBAAyBnB,EAAmBzE,EAAoBO,EAAgBjB,IAE5F,OAAO,IAAI8B,EAAWC,EAAkB3c,SAvhC5C,iIAqiCE,UACEmgB,EACAtE,EACAjB,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAU6D,gCAAgChB,EAA0BtE,EAAgBjB,IAEtF,OAAO,IAAI8B,EAAWC,EAAkB3c,SAhjC5C,8GA6jCE,UAAsBohB,EAAkCxG,GACjDA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAAa1B,EAAU+D,eAAeD,EAAsBxG,IAChG,OAAO,IAAI8B,EAAWC,EAAkB3c,SAlkC5C,qHAglCE,UACE2f,EACAhQ,EACA2L,EACAO,EACAJ,EACAb,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAUvB,yBACR4D,EACAhQ,EACA2L,EACAO,EACAJ,EACAb,IAGJ,OAAO,IAAI8B,EAAWC,EAAkB3c,SArmC5C,+HAmnCE,UACE+f,EACAzE,EACAO,EACAJ,EACAb,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAUgE,0BACRvB,EACAzE,EACAO,EACAJ,EACAb,IAGJ,OAAO,IAAI8B,EAAWC,EAAkB3c,SAtoC5C,oIAmpCE,UACEmgB,EACAtE,EACAJ,EACAb,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAUiE,iCAAiCpB,EAA0BtE,EAAgBJ,EAAab,IAEpG,OAAO,IAAI8B,EAAWC,EAAkB3c,SA/pC5C,iHA2qCE,UACEohB,EACA3F,EACAb,GAEKA,IACHA,EAAgB5a,KAAKge,iBAEvB,IAAMrB,QAAyB3c,KAAKgf,aAClC1B,EAAUkE,gBAAgBJ,EAAsB3F,EAAab,IAE/D,OAAO,IAAI8B,EAAWC,EAAkB3c,SAtrC5C","file":"static/js/3.e1f2aac7.chunk.js","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar HardwareSdk = require('@onekeyfe/hd-core');\nvar hdShared = require('@onekeyfe/hd-shared');\nvar ReactNativeTransport = require('@onekeyfe/hd-transport-react-native');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar HardwareSdk__default = /*#__PURE__*/_interopDefaultLegacy(HardwareSdk);\nvar ReactNativeTransport__default = /*#__PURE__*/_interopDefaultLegacy(ReactNativeTransport);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nvar events = {exports: {}};\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  };\n\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\nconst eventEmitter = new events.exports();\nconst Log = HardwareSdk.initLog('@onekey/hd-ble-sdk');\nlet _core;\nlet _settings = HardwareSdk.parseConnectSettings();\nlet _messageID = 0;\nconst messagePromises = {};\nconst dispose = () => {\n    eventEmitter.removeAllListeners();\n    _settings = HardwareSdk.parseConnectSettings();\n};\nconst uiResponse = (response) => {\n    if (!_core) {\n        throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.NotInitialized);\n    }\n    const { type, payload } = response;\n    _core.handleMessage({ event: HardwareSdk.UI_EVENT, type, payload });\n};\nconst cancel = (connectId) => {\n    if (_core === undefined)\n        return;\n    _core.handleMessage({ event: HardwareSdk.IFRAME.CANCEL, type: HardwareSdk.IFRAME.CANCEL, payload: { connectId } });\n};\nfunction handleMessage(message) {\n    const { event } = message;\n    if (!_core) {\n        return;\n    }\n    Log.debug('hd-ble-sdk handleMessage', message);\n    switch (event) {\n        case HardwareSdk.UI_EVENT:\n            eventEmitter.emit(message.event, message);\n            eventEmitter.emit(message.type, message.payload);\n            break;\n        default:\n            Log.log('No need to be captured message', message.event);\n    }\n}\nfunction postMessage(message, usePromise = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!_core) {\n            throw hdShared.ERRORS.TypedError('postMessage: _core not found');\n        }\n        if (usePromise) {\n            _messageID++;\n            messagePromises[_messageID] = hdShared.createDeferred();\n            const response = yield _core.handleMessage(Object.assign(Object.assign({}, message), { id: `${_messageID}` }));\n            return response;\n        }\n        _core.handleMessage(message);\n    });\n}\nconst init = (settings) => __awaiter(void 0, void 0, void 0, function* () {\n    _settings = Object.assign(Object.assign(Object.assign({}, _settings), settings), { env: 'react-native' });\n    HardwareSdk.enableLog(!!settings.debug);\n    Log.debug('init');\n    try {\n        _core = yield HardwareSdk.initCore(_settings, ReactNativeTransport__default[\"default\"]);\n        _core === null || _core === void 0 ? void 0 : _core.on(HardwareSdk.CORE_EVENT, handleMessage);\n        return true;\n    }\n    catch (error) {\n        Log.error(HardwareSdk.createErrorMessage(error));\n        return false;\n    }\n});\nconst call = (params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b;\n    Log.debug('call: ', params);\n    try {\n        const response = yield postMessage({ event: HardwareSdk.IFRAME.CALL, type: HardwareSdk.IFRAME.CALL, payload: params });\n        if (response) {\n            Log.debug('response: ', response);\n            if (!response.success) {\n                if (((_a = response.payload) === null || _a === void 0 ? void 0 : _a.code) === hdShared.HardwareErrorCode.BlePermissionError) {\n                    postMessage(HardwareSdk.createUiMessage(HardwareSdk.UI_REQUEST.BLUETOOTH_PERMISSION), false);\n                }\n                if (((_b = response.payload) === null || _b === void 0 ? void 0 : _b.code) === hdShared.HardwareErrorCode.BleLocationError) {\n                    postMessage(HardwareSdk.createUiMessage(HardwareSdk.UI_REQUEST.LOCATION_PERMISSION), false);\n                }\n            }\n            return response;\n        }\n        return HardwareSdk.createErrorMessage(hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.CallMethodNotResponse));\n    }\n    catch (error) {\n        Log.error('__call error: ', error);\n        return HardwareSdk.createErrorMessage(error);\n    }\n});\nconst HardwareBleSdk = HardwareSdk__default[\"default\"]({\n    eventEmitter,\n    init,\n    call,\n    cancel,\n    dispose,\n    uiResponse,\n});\n\nexports[\"default\"] = HardwareBleSdk;\nexports.messagePromises = messagePromises;\n","'use strict';\n\nvar reactNative = require('react-native');\nvar buffer = require('buffer');\nvar reactNativeBlePlx = require('react-native-ble-plx');\nvar ByteBuffer = require('bytebuffer');\nvar transport = require('@onekeyfe/hd-transport');\nvar hdShared = require('@onekeyfe/hd-shared');\nvar BleManager = require('react-native-ble-manager');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar ByteBuffer__default = /*#__PURE__*/_interopDefaultLegacy(ByteBuffer);\nvar transport__default = /*#__PURE__*/_interopDefaultLegacy(transport);\nvar BleManager__default = /*#__PURE__*/_interopDefaultLegacy(BleManager);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nconst initializeBleManager = () => {\n    BleManager__default[\"default\"].start({ showAlert: false });\n};\nconst getConnectedDeviceIds = (serviceUuids) => __awaiter(void 0, void 0, void 0, function* () {\n    const connectedPeripherals = yield BleManager__default[\"default\"].getConnectedPeripherals(serviceUuids);\n    return connectedPeripherals.map(peripheral => {\n        const { id, name, advertising = {} } = peripheral;\n        return Object.assign({ id, name }, advertising);\n    });\n});\nconst getBondedDevices = () => __awaiter(void 0, void 0, void 0, function* () {\n    const peripherals = yield BleManager__default[\"default\"].getBondedPeripherals();\n    return peripherals.map(peripheral => {\n        const { id, name, advertising = {} } = peripheral;\n        return Object.assign({ id, name }, advertising);\n    });\n});\n\nconst timer = process.env.NODE_ENV === 'development'\n    ? {\n        timeout: (fn, ms) => {\n            const startTime = Date.now();\n            const interval = setInterval(() => {\n                if (Date.now() - startTime >= ms) {\n                    clearInterval(interval);\n                    fn();\n                }\n            }, 100);\n            return () => {\n                clearInterval(interval);\n            };\n        },\n    }\n    : {\n        timeout: (fn, ms) => {\n            const timeout = setTimeout(fn, ms);\n            return () => clearTimeout(timeout);\n        },\n    };\n\nconst subscribeBleOn = (bleManager, ms = 1000) => new Promise((resolve, reject) => {\n    let done = false;\n    const subscription = bleManager.onStateChange(state => {\n        console.log('ble state -> ', state);\n        if (state === 'PoweredOn') {\n            if (done)\n                return;\n            clearTimeout();\n            done = true;\n            subscription.remove();\n            resolve();\n        }\n    }, true);\n    const clearTimeout = timer.timeout(() => {\n        if (done)\n            return;\n        subscription.remove();\n        reject(hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BlePermissionError));\n    }, ms);\n});\n\nconst IOS_PACKET_LENGTH = 128;\nconst ANDROID_PACKET_LENGTH = 192;\nconst isOnekeyDevice = (name, id) => {\n    var _a;\n    if ((_a = id === null || id === void 0 ? void 0 : id.startsWith) === null || _a === void 0 ? void 0 : _a.call(id, 'MI')) {\n        return true;\n    }\n    const re = /(BixinKey\\d{10})|(K\\d{4})|(T\\d{4})/i;\n    if (name && re.exec(name)) {\n        return true;\n    }\n    return false;\n};\nconst ClassicServiceUUID = '00000001-0000-1000-8000-00805f9b34fb';\nconst OneKeyServices = {\n    classic: {\n        [ClassicServiceUUID]: {\n            serviceUuid: ClassicServiceUUID,\n            writeUuid: '00000002-0000-1000-8000-00805f9b34fb',\n            notifyUuid: '00000003-0000-1000-8000-00805f9b34fb',\n        },\n    },\n};\nconst bluetoothServices = [];\nfor (const deviceType of Object.keys(OneKeyServices)) {\n    const services = OneKeyServices[deviceType];\n    bluetoothServices.push(...Object.keys(services));\n}\nconst getBluetoothServiceUuids = () => bluetoothServices;\nconst getInfosForServiceUuid = (serviceUuid, deviceType) => {\n    const services = OneKeyServices[deviceType];\n    if (!services) {\n        return null;\n    }\n    const service = services[serviceUuid];\n    if (!service) {\n        return null;\n    }\n    return service;\n};\n\nconst isHeaderChunk = (chunk) => {\n    if (chunk.length < 9)\n        return false;\n    const [MagicQuestionMark, sharp1, sharp2] = chunk;\n    if (String.fromCharCode(MagicQuestionMark) === String.fromCharCode(transport.MESSAGE_TOP_CHAR) &&\n        String.fromCharCode(sharp1) === String.fromCharCode(transport.MESSAGE_HEADER_BYTE) &&\n        String.fromCharCode(sharp2) === String.fromCharCode(transport.MESSAGE_HEADER_BYTE)) {\n        return true;\n    }\n    return false;\n};\n\nclass BleTransport {\n    constructor(device, writeCharacteristic, notifyCharacteristic) {\n        this.mtuSize = 20;\n        this.id = device.id;\n        this.device = device;\n        this.writeCharacteristic = writeCharacteristic;\n        this.notifyCharacteristic = notifyCharacteristic;\n        console.log(`BleTransport(${String(this.id)}) new instance`);\n    }\n}\n\nconst { check, buildBuffers, receiveOne, parseConfigure } = transport__default[\"default\"];\nconst transportCache = {};\nlet connectOptions = {\n    requestMTU: 512,\n    timeout: 3000,\n};\nconst tryToGetConfiguration = (device) => {\n    if (!device || !device.serviceUUIDs)\n        return null;\n    const [serviceUUID] = device.serviceUUIDs;\n    const infos = getInfosForServiceUuid(serviceUUID, 'classic');\n    if (!infos)\n        return null;\n    return infos;\n};\nclass ReactNativeBleTransport {\n    constructor(options) {\n        var _a;\n        this.configured = false;\n        this.stopped = false;\n        this.scanTimeout = 3000;\n        this.runPromise = null;\n        this.scanTimeout = (_a = options.scanTimeout) !== null && _a !== void 0 ? _a : 3000;\n    }\n    init() { }\n    configure(signedData) {\n        const messages = parseConfigure(signedData);\n        this.configured = true;\n        this._messages = messages;\n    }\n    listen() {\n    }\n    getPlxManager() {\n        if (this.blePlxManager)\n            return Promise.resolve(this.blePlxManager);\n        this.blePlxManager = new reactNativeBlePlx.BleManager();\n        initializeBleManager();\n        return Promise.resolve(this.blePlxManager);\n    }\n    enumerate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const deviceList = [];\n                const blePlxManager = yield this.getPlxManager();\n                try {\n                    yield subscribeBleOn(blePlxManager);\n                }\n                catch (error) {\n                    console.log('subscribeBleOn error: ', error);\n                    reject(error);\n                    return;\n                }\n                blePlxManager.startDeviceScan(null, {\n                    scanMode: reactNativeBlePlx.ScanMode.LowLatency,\n                }, (error, device) => {\n                    var _a, _b;\n                    if (error) {\n                        console.log('ble scan manager: ', blePlxManager);\n                        console.log('ble scan error: ', error);\n                        if ([reactNativeBlePlx.BleErrorCode.BluetoothPoweredOff, reactNativeBlePlx.BleErrorCode.BluetoothInUnknownState].includes(error.errorCode)) {\n                            reject(hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BlePermissionError));\n                        }\n                        else if (error.errorCode === reactNativeBlePlx.BleErrorCode.BluetoothUnauthorized) {\n                            reject(hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleLocationError));\n                        }\n                        else {\n                            reject(hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleScanError, (_a = error.reason) !== null && _a !== void 0 ? _a : ''));\n                        }\n                        return;\n                    }\n                    if (isOnekeyDevice((_b = device === null || device === void 0 ? void 0 : device.name) !== null && _b !== void 0 ? _b : null, device === null || device === void 0 ? void 0 : device.id)) {\n                        console.log('search device start ======================');\n                        const { name, localName, id } = device !== null && device !== void 0 ? device : {};\n                        console.log(`device name: ${name !== null && name !== void 0 ? name : ''}\\nlocalName: ${localName !== null && localName !== void 0 ? localName : ''}\\nid: ${id !== null && id !== void 0 ? id : ''}`);\n                        addDevice(device);\n                        console.log('search device end ======================\\n');\n                    }\n                });\n                getConnectedDeviceIds(getBluetoothServiceUuids()).then(devices => {\n                    for (const device of devices) {\n                        console.log('search connected peripheral: ', device.id);\n                        addDevice(device);\n                    }\n                });\n                const addDevice = (device) => {\n                    if (deviceList.every(d => d.id !== device.id)) {\n                        deviceList.push(device);\n                    }\n                };\n                timer.timeout(() => {\n                    blePlxManager.stopDeviceScan();\n                    resolve(deviceList);\n                }, this.scanTimeout);\n            }));\n        });\n    }\n    acquire(input) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { uuid } = input;\n            if (!uuid) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleRequiredUUID);\n            }\n            let device = null;\n            if (transportCache[uuid]) {\n                console.log('@onekey/hd-ble-sdk transport not be released, will release: ', uuid);\n                yield this.release(uuid);\n            }\n            const blePlxManager = yield this.getPlxManager();\n            try {\n                yield subscribeBleOn(blePlxManager);\n            }\n            catch (error) {\n                console.log('subscribeBleOn error: ', error);\n                throw error;\n            }\n            if (!device) {\n                const devices = yield blePlxManager.devices([uuid]);\n                [device] = devices;\n            }\n            if (!device) {\n                const connectedDevice = yield blePlxManager.connectedDevices(getBluetoothServiceUuids());\n                const deviceFilter = connectedDevice.filter(device => device.id === uuid);\n                console.log(`found connected device count: ${deviceFilter.length}`);\n                [device] = deviceFilter;\n            }\n            if (!device) {\n                console.log('try to connect to device: ', uuid);\n                try {\n                    device = yield blePlxManager.connectToDevice(uuid, connectOptions);\n                }\n                catch (e) {\n                    console.log('try to connect to device has error: ', e);\n                    if (e.errorCode === reactNativeBlePlx.BleErrorCode.DeviceMTUChangeFailed ||\n                        e.errorCode === reactNativeBlePlx.BleErrorCode.OperationCancelled) {\n                        connectOptions = {};\n                        device = yield blePlxManager.connectToDevice(uuid);\n                    }\n                    else {\n                        throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleConnectedError, (_a = e.reason) !== null && _a !== void 0 ? _a : e);\n                    }\n                }\n            }\n            if (!device) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleConnectedError, 'unable to connect to device');\n            }\n            if (!(yield device.isConnected())) {\n                console.log('not connected, try to connect to device: ', uuid);\n                try {\n                    yield device.connect(connectOptions);\n                }\n                catch (e) {\n                    console.log('try to connect to device has error: ', e);\n                    if (e.errorCode === reactNativeBlePlx.BleErrorCode.DeviceMTUChangeFailed ||\n                        e.errorCode === reactNativeBlePlx.BleErrorCode.OperationCancelled) {\n                        connectOptions = {};\n                        yield device.connect();\n                    }\n                    else {\n                        throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleConnectedError, (_b = e.reason) !== null && _b !== void 0 ? _b : e);\n                    }\n                }\n            }\n            if (reactNative.Platform.OS === 'android') {\n                const bondedDevices = yield getBondedDevices();\n                const hasBonded = !!bondedDevices.find(bondedDevice => bondedDevice.id === (device === null || device === void 0 ? void 0 : device.id));\n                if (!hasBonded) {\n                    throw hdShared.ERRORS.TypedError('device is not bonded');\n                }\n            }\n            yield device.discoverAllServicesAndCharacteristics();\n            let infos = tryToGetConfiguration(device);\n            let characteristics;\n            if (!infos) {\n                for (const serviceUuid of getBluetoothServiceUuids()) {\n                    try {\n                        characteristics = yield device.characteristicsForService(serviceUuid);\n                        infos = getInfosForServiceUuid(serviceUuid, 'classic');\n                        break;\n                    }\n                    catch (e) {\n                        console.log(e);\n                    }\n                }\n            }\n            if (!infos) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleServiceNotFound);\n            }\n            const { serviceUuid, writeUuid, notifyUuid } = infos;\n            if (!characteristics) {\n                characteristics = yield device.characteristicsForService(serviceUuid);\n            }\n            if (!characteristics) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleCharacteristicNotFound);\n            }\n            let writeCharacteristic;\n            let notifyCharacteristic;\n            for (const c of characteristics) {\n                if (c.uuid === writeUuid) {\n                    writeCharacteristic = c;\n                }\n                else if (c.uuid === notifyUuid) {\n                    notifyCharacteristic = c;\n                }\n            }\n            if (!writeCharacteristic) {\n                throw hdShared.ERRORS.TypedError('BLECharacteristicNotFound: write characteristic not found');\n            }\n            if (!notifyCharacteristic) {\n                throw hdShared.ERRORS.TypedError('BLECharacteristicNotFound: notify characteristic not found');\n            }\n            if (!writeCharacteristic.isWritableWithResponse) {\n                throw hdShared.ERRORS.TypedError('BLECharacteristicNotWritable: write characteristic not writable');\n            }\n            if (!notifyCharacteristic.isNotifiable) {\n                throw hdShared.ERRORS.TypedError('BLECharacteristicNotNotifiable: notify characteristic not notifiable');\n            }\n            const transport = new BleTransport(device, writeCharacteristic, notifyCharacteristic);\n            transport.nofitySubscription = this._monitorCharacteristic(transport.notifyCharacteristic);\n            transportCache[uuid] = transport;\n            const disconnectSubscription = device.onDisconnected(() => {\n                console.log('device disconnect: ', device === null || device === void 0 ? void 0 : device.id);\n                this.release(uuid);\n                disconnectSubscription === null || disconnectSubscription === void 0 ? void 0 : disconnectSubscription.remove();\n            });\n            return { uuid };\n        });\n    }\n    _monitorCharacteristic(characteristic) {\n        let bufferLength = 0;\n        let buffer$1 = [];\n        const subscription = characteristic.monitor((error, c) => {\n            var _a, _b, _c;\n            if (error) {\n                console.log(`error monitor ${characteristic.uuid}, deviceId: ${characteristic.deviceID}: ${error}`);\n                if (this.runPromise) {\n                    this.runPromise.reject(hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleCharacteristicNotifyError, (_a = error.reason) !== null && _a !== void 0 ? _a : error.message));\n                    console.log('@onekey/hd-ble-sdk: monitor notify error, and has unreleased Promise');\n                }\n                return;\n            }\n            if (!c) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleMonitorError);\n            }\n            try {\n                const data = buffer.Buffer.from(c.value, 'base64');\n                if (isHeaderChunk(data)) {\n                    bufferLength = data.readInt32BE(5);\n                    buffer$1 = [...data.subarray(3)];\n                }\n                else {\n                    buffer$1 = buffer$1.concat([...data]);\n                }\n                if (buffer$1.length - transport.COMMON_HEADER_SIZE >= bufferLength) {\n                    const value = buffer.Buffer.from(buffer$1);\n                    bufferLength = 0;\n                    buffer$1 = [];\n                    (_b = this.runPromise) === null || _b === void 0 ? void 0 : _b.resolve(value.toString('hex'));\n                }\n            }\n            catch (error) {\n                console.log('monitor data error: ', error);\n                (_c = this.runPromise) === null || _c === void 0 ? void 0 : _c.reject(error);\n            }\n        });\n        return () => {\n            console.log('remove characteristic monitor: ', characteristic.uuid);\n            subscription.remove();\n        };\n    }\n    release(uuid) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = transportCache[uuid];\n            if (transport) {\n                delete transportCache[uuid];\n                (_a = transport.nofitySubscription) === null || _a === void 0 ? void 0 : _a.call(transport);\n                if (reactNative.Platform.OS === 'android') {\n                    yield ((_b = this.blePlxManager) === null || _b === void 0 ? void 0 : _b.cancelDeviceConnection(uuid));\n                }\n            }\n            return Promise.resolve(true);\n        });\n    }\n    call(uuid, name, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.stopped) {\n                return Promise.reject(hdShared.ERRORS.TypedError('Transport stopped.'));\n            }\n            if (this._messages == null) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.TransportNotConfigured);\n            }\n            if (this.runPromise) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.TransportCallInProgress);\n            }\n            const transport = transportCache[uuid];\n            if (!transport) {\n                throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.TransportNotFound);\n            }\n            this.runPromise = hdShared.createDeferred();\n            const messages = this._messages;\n            console.log('transport-react-native', 'call-', ' name: ', name, ' data: ', data);\n            const buffers = buildBuffers(messages, name, data);\n            if (name === 'FirmwareUpload') {\n                const packetCapacity = reactNative.Platform.OS === 'ios' ? IOS_PACKET_LENGTH : ANDROID_PACKET_LENGTH;\n                let index = 0;\n                let chunk = ByteBuffer__default[\"default\"].allocate(packetCapacity);\n                while (index < buffers.length) {\n                    const buffer = buffers[index].toBuffer();\n                    chunk.append(buffer);\n                    index += 1;\n                    if (chunk.offset === packetCapacity || index >= buffers.length) {\n                        chunk.reset();\n                        console.log('@onekey/hd-ble-sdk send more packet hex strting: ', chunk.toString('hex'));\n                        try {\n                            yield transport.writeCharacteristic.writeWithoutResponse(chunk.toString('base64'));\n                            chunk = ByteBuffer__default[\"default\"].allocate(packetCapacity);\n                        }\n                        catch (e) {\n                            this.runPromise = null;\n                            console.log('writeCharacteristic write error: ', e);\n                            return;\n                        }\n                    }\n                }\n            }\n            else {\n                for (const o of buffers) {\n                    const outData = o.toString('base64');\n                    console.log('@onekey/hd-ble-sdk send hex strting: ', o.toString('hex'));\n                    try {\n                        yield transport.writeCharacteristic.writeWithoutResponse(outData);\n                    }\n                    catch (e) {\n                        if (e.errorCode === reactNativeBlePlx.BleErrorCode.DeviceDisconnected) {\n                            throw hdShared.ERRORS.TypedError(hdShared.HardwareErrorCode.BleDeviceNotBonded);\n                        }\n                        this.runPromise = null;\n                        console.log('writeCharacteristic write error: ', e);\n                        return;\n                    }\n                }\n            }\n            try {\n                const response = yield this.runPromise.promise;\n                if (typeof response !== 'string') {\n                    throw new Error('Returning data is not string.');\n                }\n                console.log('@onekey/hd-ble-sdk receive data: ', response);\n                const jsonData = receiveOne(messages, response);\n                return check.call(jsonData);\n            }\n            catch (e) {\n                console.log('call error: ', e);\n                return e;\n            }\n            finally {\n                this.runPromise = null;\n            }\n        });\n    }\n    stop() {\n        this.stopped = true;\n    }\n    cancel() {\n        console.log('transport-react-native canceled');\n        if (this.runPromise) ;\n        this.runPromise = null;\n    }\n}\n\nmodule.exports = ReactNativeBleTransport;\n","// @flow\n'use strict'\n\nimport type { UUID } from './TypeDefinition'\n\n/**\n * Converts UUID to full 128bit, lowercase format which should be used to compare UUID values.\n *\n * @param {UUID} uuid 16bit, 32bit or 128bit UUID.\n * @returns {UUID} 128bit lowercase UUID.\n */\nexport function fullUUID(uuid: UUID): UUID {\n  if (uuid.length === 4) return '0000' + uuid.toLowerCase() + '-0000-1000-8000-00805f9b34fb'\n  if (uuid.length === 8) return uuid.toLowerCase() + '-0000-1000-8000-00805f9b34fb'\n  return uuid.toLowerCase()\n}\n\nexport function fillStringWithArguments(value: string, object: Object) {\n  return value.replace(/\\{([^}]+)\\}/g, function(_, arg: string) {\n    return object[arg] || '?'\n  })\n}\n","// @flow\nimport { fillStringWithArguments } from './Utils'\nimport type { BleErrorCodeMessageMapping } from './TypeDefinition'\n\nexport interface NativeBleError {\n  errorCode: $Values<typeof BleErrorCode>;\n  attErrorCode: ?$Values<typeof BleATTErrorCode>;\n  iosErrorCode: ?$Values<typeof BleIOSErrorCode>;\n  androidErrorCode: ?$Values<typeof BleAndroidErrorCode>;\n  reason: ?string;\n\n  deviceID?: string;\n  serviceUUID?: string;\n  characteristicUUID?: string;\n  descriptorUUID?: string;\n  internalMessage?: string;\n}\n\n/**\n * BleError is an error class which is guaranteed to be thrown by all functions of this\n * library. It contains additional properties which help to identify problems in\n * platform independent way.\n */\nexport class BleError extends Error {\n  /**\n   * Platform independent error code. Possible values are defined in {@link BleErrorCode}.\n   */\n  errorCode: $Values<typeof BleErrorCode>\n  /**\n   * Platform independent error code related to ATT errors.\n   */\n  attErrorCode: ?$Values<typeof BleATTErrorCode>\n  /**\n   * iOS specific error code (if not an ATT error).\n   */\n  iosErrorCode: ?$Values<typeof BleIOSErrorCode>\n  /**\n   * Android specific error code (if not an ATT error).\n   */\n  androidErrorCode: ?$Values<typeof BleAndroidErrorCode>\n  /**\n   * Platform specific error message.\n   */\n  reason: ?string\n\n  constructor(nativeBleError: NativeBleError | string, errorMessageMapping: BleErrorCodeMessageMapping) {\n    super()\n    this.message = errorMessageMapping[BleErrorCode.UnknownError]\n    if (typeof nativeBleError === 'string') {\n      this.errorCode = BleErrorCode.UnknownError\n      this.attErrorCode = null\n      this.iosErrorCode = null\n      this.androidErrorCode = null\n      this.reason = nativeBleError\n    } else {\n      const message = errorMessageMapping[nativeBleError.errorCode]\n      if (message) {\n        this.message = fillStringWithArguments(message, nativeBleError)\n      }\n      this.errorCode = nativeBleError.errorCode\n      this.attErrorCode = nativeBleError.attErrorCode\n      this.iosErrorCode = nativeBleError.iosErrorCode\n      this.androidErrorCode = nativeBleError.androidErrorCode\n      this.reason = nativeBleError.reason\n    }\n    this.name = 'BleError'\n  }\n}\n\nexport function parseBleError(errorMessage: string, errorMessageMapping: BleErrorCodeMessageMapping): BleError {\n  let bleError: BleError\n  const errorMapping = errorMessageMapping ? errorMessageMapping : BleErrorCodeMessage\n  try {\n    const nativeBleError = JSON.parse(errorMessage)\n    bleError = new BleError(nativeBleError, errorMapping)\n  } catch (parseError) {\n    bleError = new BleError(errorMessage, errorMapping)\n  }\n  return bleError\n}\n\n/**\n * Platform independent error code map adjusted to this library's use cases.\n */\nexport const BleErrorCode = {\n  // Implementation specific errors ------------------------------------------------------------------------------------\n  /**\n   * This error can be thrown when unexpected error occurred and in most cases it is related to implementation bug.\n   * Original message is available in {@link #bleerrorreason|reason} property.\n   */\n  UnknownError: 0,\n  /**\n   * Current promise failed to finish due to BleManager shutdown. It means that user called\n   * {@link #blemanagerdestroy|manager.destroy()} function before all operations completed.\n   */\n  BluetoothManagerDestroyed: 1,\n  /**\n   * Promise was explicitly cancelled by a user with {@link #blemanagercanceltransaction|manager.cancelTransaction()}\n   * function call.\n   */\n  OperationCancelled: 2,\n  /**\n   * Operation timed out and was cancelled.\n   */\n  OperationTimedOut: 3,\n  /**\n   * Native module couldn't start operation due to internal state, which doesn't allow to do that.\n   */\n  OperationStartFailed: 4,\n  /**\n   * Invalid UUIDs or IDs were passed to API call.\n   */\n  InvalidIdentifiers: 5,\n\n  // Bluetooth global states -------------------------------------------------------------------------------------------\n  /**\n   * Bluetooth is not supported for this particular device. It may happen on iOS simulator for example.\n   */\n  BluetoothUnsupported: 100,\n  /**\n   * There are no granted permissions which allow to use BLE functionality. On Android it may require\n   * android.permission.ACCESS_COARSE_LOCATION permission or android.permission.ACCESS_FINE_LOCATION permission.\n   */\n  BluetoothUnauthorized: 101,\n  /**\n   * BLE is powered off on device. All previous operations and their state is invalidated.\n   */\n  BluetoothPoweredOff: 102,\n  /**\n   * BLE stack is in unspecified state.\n   */\n  BluetoothInUnknownState: 103,\n  /**\n   * BLE stack is resetting.\n   */\n  BluetoothResetting: 104,\n  /**\n   * BLE state change failed.\n   */\n  BluetoothStateChangeFailed: 105,\n\n  // Peripheral errors. ------------------------------------------------------------------------------------------------\n  /**\n   * Couldn't connect to specified device.\n   */\n  DeviceConnectionFailed: 200,\n  /**\n   * Device was disconnected.\n   */\n  DeviceDisconnected: 201,\n  /**\n   * Couldn't read RSSI from device.\n   */\n  DeviceRSSIReadFailed: 202,\n  /**\n   * Device is already connected. It is not allowed to connect twice to the same device.\n   */\n  DeviceAlreadyConnected: 203,\n  /**\n   * Couldn't find device with specified ID.\n   */\n  DeviceNotFound: 204,\n  /**\n   * Operation failed because device has to be connected to perform it.\n   */\n  DeviceNotConnected: 205,\n  /**\n   * Device could not change MTU value.\n   */\n  DeviceMTUChangeFailed: 206,\n\n  // Services ----------------------------------------------------------------------------------------------------------\n  /**\n   * Couldn't discover services for specified device.\n   */\n  ServicesDiscoveryFailed: 300,\n  /**\n   * Couldn't discover included services for specified service.\n   */\n  IncludedServicesDiscoveryFailed: 301,\n  /**\n   * Service with specified ID or UUID couldn't be found. User may need to call\n   * {@link #blemanagerdiscoverallservicesandcharacteristicsfordevice|manager.discoverAllServicesAndCharacteristicsForDevice}\n   * to cache them.\n   */\n  ServiceNotFound: 302,\n  /**\n   * Services were not discovered. User may need to call\n   * {@link #blemanagerdiscoverallservicesandcharacteristicsfordevice|manager.discoverAllServicesAndCharacteristicsForDevice}\n   * to cache them.\n   */\n  ServicesNotDiscovered: 303,\n\n  // Characteristics ---------------------------------------------------------------------------------------------------\n  /**\n   * Couldn't discover characteristics for specified service.\n   */\n  CharacteristicsDiscoveryFailed: 400,\n  /**\n   * Couldn't write to specified characteristic. Make sure that\n   * {@link #characteristiciswritablewithresponse|characteristic.isWritableWithResponse}\n   * or {@link #characteristiciswritablewithoutresponse|characteristic.isWritableWithoutResponse} is set to true.\n   */\n  CharacteristicWriteFailed: 401,\n  /**\n   * Couldn't read from specified characteristic. Make sure that\n   * {@link #characteristicisreadable|characteristic.isReadable} is set to true.\n   */\n  CharacteristicReadFailed: 402,\n  /**\n   * Couldn't set notification or indication for specified characteristic. Make sure that\n   * {@link #characteristicisnotifiable|characteristic.isNotifiable} or\n   * {@link #characteristicisindicatable|characteristic.isIndicatable} is set to true.\n   */\n  CharacteristicNotifyChangeFailed: 403,\n  /**\n   * Characteristic with specified ID or UUID couldn't be found. User may need to call\n   * {@link #blemanagerdiscoverallservicesandcharacteristicsfordevice|manager.discoverAllServicesAndCharacteristicsForDevice}\n   * to cache them.\n   */\n  CharacteristicNotFound: 404,\n  /**\n   * Characteristic were not discovered for specified service. User may need to call\n   * {@link #blemanagerdiscoverallservicesandcharacteristicsfordevice|manager.discoverAllServicesAndCharacteristicsForDevice}\n   * to cache them.\n   */\n  CharacteristicsNotDiscovered: 405,\n  /**\n   * Invalid Base64 format was passed to characteristic API function call.\n   */\n  CharacteristicInvalidDataFormat: 406,\n\n  // Characteristics ---------------------------------------------------------------------------------------------------\n  /**\n   * Couldn't discover descriptor for specified characteristic.\n   */\n  DescriptorsDiscoveryFailed: 500,\n  /**\n   * Couldn't write to specified descriptor.\n   */\n  DescriptorWriteFailed: 501,\n  /**\n   * Couldn't read from specified descriptor.\n   */\n  DescriptorReadFailed: 502,\n  /**\n   * Couldn't find specified descriptor.\n   */\n  DescriptorNotFound: 503,\n  /**\n   * Descriptors are not discovered for specified characteristic.\n   */\n  DescriptorsNotDiscovered: 504,\n  /**\n   * Invalid Base64 format was passed to descriptor API function call.\n   */\n  DescriptorInvalidDataFormat: 505,\n  /**\n   * Issued a write to a descriptor, which is handled by OS.\n   */\n  DescriptorWriteNotAllowed: 506,\n\n  // Scanning errors ---------------------------------------------------------------------------------------------------\n  /**\n   * Cannot start scanning operation.\n   */\n  ScanStartFailed: 600,\n  /**\n   * Location services are disabled.\n   */\n  LocationServicesDisabled: 601\n}\n\n/**\n * Mapping of error codes to error messages\n * @name BleErrorCodeMessage\n */\nexport const BleErrorCodeMessage: BleErrorCodeMessageMapping = {\n  // Implementation specific errors\n  [BleErrorCode.UnknownError]: 'Unknown error occurred. This is probably a bug! Check reason property.',\n  [BleErrorCode.BluetoothManagerDestroyed]: 'BleManager was destroyed',\n  [BleErrorCode.OperationCancelled]: 'Operation was cancelled',\n  [BleErrorCode.OperationTimedOut]: 'Operation timed out',\n  [BleErrorCode.OperationStartFailed]: 'Operation was rejected',\n  [BleErrorCode.InvalidIdentifiers]: 'Invalid UUIDs or IDs were passed: {internalMessage}',\n\n  // Bluetooth global states\n  [BleErrorCode.BluetoothUnsupported]: 'BluetoothLE is unsupported on this device',\n  [BleErrorCode.BluetoothUnauthorized]: 'Device is not authorized to use BluetoothLE',\n  [BleErrorCode.BluetoothPoweredOff]: 'BluetoothLE is powered off',\n  [BleErrorCode.BluetoothInUnknownState]: 'BluetoothLE is in unknown state',\n  [BleErrorCode.BluetoothResetting]: 'BluetoothLE is resetting',\n  [BleErrorCode.BluetoothStateChangeFailed]: 'Bluetooth state change failed',\n\n  // Peripheral errors.\n  [BleErrorCode.DeviceConnectionFailed]: 'Device {deviceID} connection failed',\n  [BleErrorCode.DeviceDisconnected]: 'Device {deviceID} was disconnected',\n  [BleErrorCode.DeviceRSSIReadFailed]: 'RSSI read failed for device {deviceID}',\n  [BleErrorCode.DeviceAlreadyConnected]: 'Device {deviceID} is already connected',\n  [BleErrorCode.DeviceNotFound]: 'Device {deviceID} not found',\n  [BleErrorCode.DeviceNotConnected]: 'Device {deviceID} is not connected',\n  [BleErrorCode.DeviceMTUChangeFailed]: 'Device {deviceID} could not change MTU size',\n\n  // Services\n  [BleErrorCode.ServicesDiscoveryFailed]: 'Services discovery failed for device {deviceID}',\n  [BleErrorCode.IncludedServicesDiscoveryFailed]:\n    'Included services discovery failed for device {deviceID} and service: {serviceUUID}',\n  [BleErrorCode.ServiceNotFound]: 'Service {serviceUUID} for device {deviceID} not found',\n  [BleErrorCode.ServicesNotDiscovered]: 'Services not discovered for device {deviceID}',\n\n  // Characteristics\n  [BleErrorCode.CharacteristicsDiscoveryFailed]:\n    'Characteristic discovery failed for device {deviceID} and service {serviceUUID}',\n  [BleErrorCode.CharacteristicWriteFailed]:\n    'Characteristic {characteristicUUID} write failed for device {deviceID} and service {serviceUUID}',\n  [BleErrorCode.CharacteristicReadFailed]:\n    'Characteristic {characteristicUUID} read failed for device {deviceID} and service {serviceUUID}',\n  [BleErrorCode.CharacteristicNotifyChangeFailed]:\n    'Characteristic {characteristicUUID} notify change failed for device {deviceID} and service {serviceUUID}',\n  [BleErrorCode.CharacteristicNotFound]: 'Characteristic {characteristicUUID} not found',\n  [BleErrorCode.CharacteristicsNotDiscovered]:\n    'Characteristics not discovered for device {deviceID} and service {serviceUUID}',\n  [BleErrorCode.CharacteristicInvalidDataFormat]:\n    'Cannot write to characteristic {characteristicUUID} with invalid data format: {internalMessage}',\n\n  // Descriptors\n  [BleErrorCode.DescriptorsDiscoveryFailed]:\n    'Descriptor {descriptorUUID} discovery failed for device {deviceID}, service {serviceUUID} and characteristic {characteristicUUID}',\n  [BleErrorCode.DescriptorWriteFailed]:\n    'Descriptor {descriptorUUID} write failed for device {deviceID}, service {serviceUUID} and characteristic {characteristicUUID}',\n  [BleErrorCode.DescriptorReadFailed]:\n    'Descriptor {descriptorUUID} read failed for device {deviceID}, service {serviceUUID} and characteristic {characteristicUUID}',\n  [BleErrorCode.DescriptorNotFound]: 'Descriptor {descriptorUUID} not found',\n  [BleErrorCode.DescriptorsNotDiscovered]:\n    'Descriptors not discovered for device {deviceID}, service {serviceUUID} and characteristic {characteristicUUID}',\n  [BleErrorCode.DescriptorInvalidDataFormat]:\n    'Cannot write to descriptor {descriptorUUID} with invalid data format: {internalMessage}',\n  [BleErrorCode.DescriptorWriteNotAllowed]:\n    \"Cannot write to descriptor {descriptorUUID}. It's not allowed by iOS and therefore forbidden on Android as well.\",\n\n  // Scanning\n  [BleErrorCode.ScanStartFailed]: 'Cannot start scanning operation',\n  [BleErrorCode.LocationServicesDisabled]: 'Location services are disabled'\n}\n\n/**\n * Error codes for ATT errors.\n * @name BleATTErrorCode\n */\nexport const BleATTErrorCode = {\n  /**\n   * The ATT command or request successfully completed.\n   */\n  Success: 0,\n  /**\n   * The attribute handle is invalid on this device.\n   */\n  InvalidHandle: 1,\n  /**\n   * The attributes value cannot be read.\n   */\n  ReadNotPermitted: 2,\n  /**\n   * The attributes value cannot be written.\n   */\n  WriteNotPermitted: 3,\n  /**\n   * The attribute Protocol Data Unit (PDU) or message is invalid.\n   */\n  InvalidPdu: 4,\n  /**\n   * The attribute requires authentication before its value can be read or written.\n   */\n  InsufficientAuthentication: 5,\n  /**\n   * The attribute server does not support the request received by the client.\n   */\n  RequestNotSupported: 6,\n  /**\n   * The specified offset value was past the end of the attributes value.\n   */\n  InvalidOffset: 7,\n  /**\n   * The attribute requires authorization before its value can be read or written.\n   */\n  InsufficientAuthorization: 8,\n  /**\n   * The prepare queue is full, because too many prepare write requests have been queued.\n   */\n  PrepareQueueFull: 9,\n  /**\n   * The attribute is not found within the specified attribute handle range.\n   */\n  AttributeNotFound: 10,\n  /**\n   * The attribute cannot be read or written using the ATT read blob request.\n   */\n  AttributeNotLong: 11,\n  /**\n   * The encryption key size used for encrypting this link is insufficient.\n   */\n  InsufficientEncryptionKeySize: 12,\n  /**\n   * The length of the attributes value is invalid for the intended operation.\n   */\n  InvalidAttributeValueLength: 13,\n  /**\n   * The ATT request has encountered an unlikely error and therefore could not be completed.\n   */\n  UnlikelyError: 14,\n  /**\n   * The attribute requires encryption before its value can be read or written.\n   */\n  InsufficientEncryption: 15,\n  /**\n   * The attribute type is not a supported grouping attribute as defined by a higher-layer specification.\n   */\n  UnsupportedGroupType: 16,\n  /**\n   * Resources are insufficient to complete the ATT request.\n   */\n  InsufficientResources: 17\n\n  // Values 0x012  0x7F are reserved for future use.\n}\n\n/**\n * iOS specific error codes.\n * @name BleIOSErrorCode\n */\nexport const BleIOSErrorCode = {\n  /**\n   * An unknown error occurred.\n   */\n  Unknown: 0,\n  /**\n   * The specified parameters are invalid.\n   */\n  InvalidParameters: 1,\n  /**\n   * The specified attribute handle is invalid.\n   */\n  InvalidHandle: 2,\n  /**\n   * The device is not currently connected.\n   */\n  NotConnected: 3,\n  /**\n   * The device has run out of space to complete the intended operation.\n   */\n  OutOfSpace: 4,\n  /**\n   * The operation is canceled.\n   */\n  OperationCancelled: 5,\n  /**\n   * The connection timed out.\n   */\n  ConnectionTimeout: 6,\n  /**\n   * The peripheral disconnected.\n   */\n  PeripheralDisconnected: 7,\n  /**\n   * The specified UUID is not permitted.\n   */\n  UuidNotAllowed: 8,\n  /**\n   * The peripheral is already advertising.\n   */\n  AlreadyAdvertising: 9,\n  /**\n   * The connection failed.\n   */\n  ConnectionFailed: 10,\n  /**\n   * The device already has the maximum number of connections.\n   */\n  ConnectionLimitReached: 11,\n  /**\n   * Unknown device.\n   */\n  UnknownDevice: 12\n}\n\n/**\n * Android specific error codes.\n * @name BleAndroidErrorCode\n */\nexport const BleAndroidErrorCode = {\n  /**\n   * The device has insufficient resources to complete the intended operation.\n   */\n  NoResources: 0x80,\n  /**\n   * Internal error occurred which may happen due to implementation error in BLE stack.\n   */\n  InternalError: 0x81,\n  /**\n   * BLE stack implementation entered illegal state and operation couldn't complete.\n   */\n  WrongState: 0x82,\n  /**\n   * BLE stack didn't allocate sufficient memory buffer for internal caches.\n   */\n  DbFull: 0x83,\n  /**\n   * Maximum number of pending operations was exceeded.\n   */\n  Busy: 0x84,\n  /**\n   * Generic BLE stack error.\n   */\n  Error: 0x85,\n  /**\n   * Command is already queued up in GATT.\n   */\n  CmdStarted: 0x86,\n  /**\n   * Illegal parameter was passed to internal BLE stack function.\n   */\n  IllegalParameter: 0x87,\n  /**\n   * Operation is pending.\n   */\n  Pending: 0x88,\n  /**\n   * Authorization failed before performing read or write operation.\n   */\n  AuthFail: 0x89,\n  /**\n   * More cache entries were loaded then expected.\n   */\n  More: 0x8a,\n  /**\n   * Invalid configuration\n   */\n  InvalidCfg: 0x8b,\n  /**\n   * GATT service already started.\n   */\n  ServiceStarted: 0x8c,\n  /**\n   * GATT link is encrypted but prone to man in the middle attacks.\n   */\n  EncrypedNoMitm: 0x8d,\n  /**\n   * GATT link is not encrypted.\n   */\n  NotEncrypted: 0x8e,\n  /**\n   * ATT command was sent but channel is congested.\n   */\n  Congested: 0x8f\n}\n","// @flow\n'use strict'\n\nimport type { Device } from './Device'\nimport { BleErrorCode } from './BleError'\n\n/**\n * Bluetooth device id.\n */\nexport type DeviceId = string\n\n/**\n * Unique identifier for BLE objects.\n */\nexport type Identifier = number\n\n/**\n * Bluetooth UUID\n */\nexport type UUID = string\n\n/**\n * Base64 value\n */\nexport type Base64 = string\n\n/**\n * Transaction identifier. All transaction identifiers in numeric form are reserved for internal use.\n */\nexport type TransactionId = string\n\n/**\n * [Android only] ConnectionOptions parameter to describe when to call BluetoothGatt.refresh()\n */\nexport type RefreshGattMoment = 'OnConnected'\n\n/**\n * Subscription\n * @interface\n */\nexport interface Subscription {\n  /**\n   * Removes subscription\n   * @memberof Subscription\n   * @ignore\n   */\n  remove(): void;\n}\n\n/**\n * Type of error code mapping table\n */\nexport type BleErrorCodeMessageMapping = { [$Values<typeof BleErrorCode>]: string }\n\n/**\n * Options which can be passed to when creating BLE Manager\n */\nexport interface BleManagerOptions {\n  /**\n   * BLE State restoration identifier used to restore state.\n   * @memberof BleManagerOptions\n   * @instance\n   */\n  restoreStateIdentifier?: string;\n\n  /**\n   * Optional function which is used to properly restore state of your BLE Manager. Callback\n   * is emitted in the beginning of BleManager creation and optional {@link BleRestoreState}\n   * is passed. When value is `null` application is launching for the first time, otherwise\n   * it contains saved state which may be used by developer to continue working with\n   * connected peripherals.\n   * @memberof BleManagerOptions\n   * @instance\n   */\n  restoreStateFunction?: (restoredState: ?BleRestoredState) => void;\n\n  /**\n   * Optional mapping of error codes to error messages. Uses {@link BleErrorCodeMessage}\n   * by default.\n   *\n   * To override logging UUIDs or MAC adresses in error messages copy the original object\n   * and overwrite values of interest to you.\n   *\n   * @memberof BleManagerOptions\n   * @instance\n   */\n  errorCodesToMessagesMapping?: BleErrorCodeMessageMapping;\n}\n\n/**\n * Object representing information about restored BLE state after application relaunch.\n */\nexport interface BleRestoredState {\n  /**\n   * List of connected devices after state restoration.\n   * @type {Array<Device>}\n   * @instance\n   * @memberof BleRestoredState\n   */\n  connectedPeripherals: Array<Device>;\n}\n\n/**\n * Scan mode for Bluetooth LE scan.\n */\nexport const ScanMode = {\n  /**\n   * A special Bluetooth LE scan mode. Applications using this scan mode will passively listen for\n   * other scan results without starting BLE scans themselves.\n   */\n  Opportunistic: -1,\n\n  /**\n   * Perform Bluetooth LE scan in low power mode. This is the default scan mode as it consumes the\n   * least power. [default value]\n   */\n  LowPower: 0,\n\n  /**\n   * Perform Bluetooth LE scan in balanced power mode. Scan results are returned at a rate that\n   * provides a good trade-off between scan frequency and power consumption.\n   */\n  Balanced: 1,\n\n  /**\n   * Scan using highest duty cycle. It's recommended to only use this mode when the application is\n   * running in the foreground.\n   */\n  LowLatency: 2\n}\n\n/**\n * Scan callback type for Bluetooth LE scan.\n * @name ScanCallbackType\n */\nexport const ScanCallbackType = {\n  /**\n   * Trigger a callback for every Bluetooth advertisement found that matches the filter criteria.\n   * If no filter is active, all advertisement packets are reported. [default value]\n   */\n  AllMatches: 1,\n\n  /**\n   * A result callback is only triggered for the first advertisement packet received that matches\n   * the filter criteria.\n   */\n  FirstMatch: 2,\n\n  /**\n   * Receive a callback when advertisements are no longer received from a device that has been\n   * previously reported by a first match callback.\n   */\n  MatchLost: 4\n}\n\n/**\n * Options which can be passed to scanning function\n * @name ScanOptions\n */\nexport interface ScanOptions {\n  /**\n   * By allowing duplicates scanning records are received more frequently [iOS only]\n   * @memberof ScanOptions\n   * @instance\n   */\n  allowDuplicates?: boolean;\n\n  /**\n   * Scan mode for Bluetooth LE scan [Android only]\n   * @memberof ScanOptions\n   * @instance\n   */\n  scanMode?: $Values<typeof ScanMode>;\n\n  /**\n   * Scan callback type for Bluetooth LE scan [Android only]\n   * @memberof ScanOptions\n   * @instance\n   */\n  callbackType?: $Values<typeof ScanCallbackType>;\n}\n\n/**\n * Connection specific options to be passed before connection happen. [Not used]\n */\nexport interface ConnectionOptions {\n  /**\n   * Whether to directly connect to the remote device (false) or to automatically connect as soon as the remote device\n   * becomes available (true). [Android only]\n   * @memberof ConnectionOptions\n   * @instance\n   */\n  autoConnect?: boolean;\n\n  /**\n   * Whether MTU size will be negotiated to this value. It is not guaranteed to get it after connection is successful.\n   *\n   * @memberof ConnectionOptions\n   * @instance\n   */\n  requestMTU?: number;\n\n  /**\n   * Whether action will be taken to reset services cache. This option may be useful when a peripheral's firmware was\n   * updated and it's services/characteristics were added/removed/altered. [Android only]\n   * {@link https://stackoverflow.com/questions/22596951/how-to-programmatically-force-bluetooth-low-energy-service-discovery-on-android}\n   * @memberof ConnectionOptions\n   * @instance\n   */\n  refreshGatt?: RefreshGattMoment;\n\n  /**\n   * Number of milliseconds after connection is automatically timed out. In case of race condition were connection is\n   * established right after timeout event, device will be disconnected immediately. Time out may happen earlier then\n   * specified due to OS specific behavior.\n   *\n   * @memberof ConnectionOptions\n   * @instance\n   */\n  timeout?: number;\n}\n\n/**\n * Device Bluetooth Low Energy state. It's keys are used to check {@link #blemanagerstate} values\n * received by {@link BleManager}\n */\nexport const State = {\n  /**\n   * The current state of the manager is unknown; an update is imminent.\n   */\n  Unknown: 'Unknown',\n  /**\n   * The connection with the system service was momentarily lost; an update is imminent.\n   */\n  Resetting: 'Resetting',\n  /**\n   * The platform does not support Bluetooth low energy.\n   */\n  Unsupported: 'Unsupported',\n  /**\n   * The app is not authorized to use Bluetooth low energy.\n   */\n  Unauthorized: 'Unauthorized',\n  /**\n   * Bluetooth is currently powered off.\n   */\n  PoweredOff: 'PoweredOff',\n  /**\n   * Bluetooth is currently powered on and available to use.\n   */\n  PoweredOn: 'PoweredOn'\n}\n\n/**\n * Native module logging log level. By default it is set to None.\n * @name LogLevel\n */\nexport const LogLevel = {\n  /**\n   * Logging in native module is disabled\n   */\n  None: 'None',\n  /**\n   * All logs in native module are shown\n   */\n  Verbose: 'Verbose',\n  /**\n   * Only debug logs and of higher importance are shown in native module.\n   */\n  Debug: 'Debug',\n  /**\n   * Only info logs and of higher importance are shown in native module.\n   */\n  Info: 'Info',\n  /**\n   * Only warning logs and of higher importance are shown in native module.\n   */\n  Warning: 'Warning',\n  /**\n   * Only error logs and of higher importance are shown in native module.\n   */\n  Error: 'Error'\n}\n\n/**\n * Connection priority of BLE link determining the balance between power consumption and data throughput.\n * @name ConnectionPriority\n */\nexport const ConnectionPriority = {\n  /**\n   * Default, recommended option balanced between power consumption and data throughput.\n   */\n  Balanced: 0,\n  /**\n   * High priority, low latency connection, which increases transfer speed at the expense of power consumption.\n   */\n  High: 1,\n  /**\n   * Low power, reduced data rate connection setup.\n   */\n  LowPower: 2\n}\n","// @flow\n'use strict'\n\nimport type { BleManager } from './BleManager'\nimport type { BleError } from './BleError'\nimport type { Characteristic } from './Characteristic'\nimport type { Service } from './Service'\nimport type { Descriptor } from './Descriptor'\nimport { ConnectionPriority } from './TypeDefinition'\nimport type { NativeDevice } from './BleModule'\nimport type { DeviceId, Base64, UUID, Subscription, TransactionId, ConnectionOptions } from './TypeDefinition'\n\n/**\n * Device instance which can be retrieved only by calling\n * {@link #blemanagerstartdevicescan|bleManager.startDeviceScan()}.\n */\nexport class Device implements NativeDevice {\n  /**\n   * Internal BLE Manager handle\n   * @private\n   */\n  _manager: BleManager\n\n  /**\n   * Device identifier: MAC address on Android and UUID on iOS.\n   */\n  id: DeviceId\n\n  /**\n   * Device name if present\n   */\n  name: ?string\n\n  /**\n   * Current Received Signal Strength Indication of device\n   */\n  rssi: ?number\n\n  /**\n   * Current Maximum Transmission Unit for this device. When device is not connected\n   * default value of 23 is used.\n   */\n  mtu: number\n\n  // Advertisement\n\n  /**\n   * Device's custom manufacturer data. Its format is defined by manufacturer.\n   */\n  manufacturerData: ?Base64\n\n  /**\n   * Map of service UUIDs (as keys) with associated data (as values).\n   */\n  serviceData: ?{ [uuid: UUID]: Base64 }\n\n  /**\n   * List of available services visible during scanning.\n   */\n  serviceUUIDs: ?Array<UUID>\n\n  /**\n   * User friendly name of device.\n   */\n  localName: ?string\n\n  /**\n   * Transmission power level of device.\n   */\n  txPowerLevel: ?number\n\n  /**\n   * List of solicited service UUIDs.\n   */\n  solicitedServiceUUIDs: ?Array<UUID>\n\n  /**\n   * Is device connectable. [iOS only]\n   */\n  isConnectable: ?boolean\n\n  /**\n   * List of overflow service UUIDs. [iOS only]\n   */\n  overflowServiceUUIDs: ?Array<UUID>\n\n  /**\n   * Private constructor used to create {@link Device} object.\n   *\n   * @param {NativeDevice} nativeDevice Native device properties\n   * @param {BleManager} manager {@link BleManager} handle\n   * @private\n   */\n  constructor(nativeDevice: NativeDevice, manager: BleManager) {\n    Object.assign(this, nativeDevice, { _manager: manager })\n  }\n\n  /**\n   * {@link #blemanagerrequestconnectionpriorityfordevice|bleManager.requestConnectionPriorityForDevice()} with partially filled arguments.\n   *\n   * @param {ConnectionPriority} connectionPriority: Connection priority.\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation.\n   * @returns {Promise<Device>} Connected device.\n   */\n  requestConnectionPriority(\n    connectionPriority: $Values<typeof ConnectionPriority>,\n    transactionId: ?TransactionId\n  ): Promise<Device> {\n    return this._manager.requestConnectionPriorityForDevice(this.id, connectionPriority, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerreadrssifordevice|bleManager.readRSSIForDevice()} with partially filled arguments.\n   *\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation.\n   * @returns {Promise<Device>} This device with updated RSSI value.\n   */\n  readRSSI(transactionId: ?TransactionId): Promise<Device> {\n    return this._manager.readRSSIForDevice(this.id, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerrequestmtufordevice|bleManager.requestMTUForDevice()} with partially filled arguments.\n   *\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation.\n   * @returns {Promise<Device>} Device with updated MTU size. Default value is 23.\n   */\n  requestMTU(mtu: number, transactionId: ?TransactionId): Promise<Device> {\n    return this._manager.requestMTUForDevice(this.id, mtu, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerconnecttodevice|bleManager.connectToDevice()} with partially filled arguments.\n   *\n   * @param {?ConnectionOptions} options Platform specific options for connection establishment. Not used currently.\n   * @returns {Promise<Device>} Connected {@link Device} object if successful.\n   */\n  connect(options: ?ConnectionOptions): Promise<Device> {\n    return this._manager.connectToDevice(this.id, options)\n  }\n\n  /**\n   * {@link #blemanagercanceldeviceconnection|bleManager.cancelDeviceConnection()} with partially filled arguments.\n   *\n   * @returns {Promise<Device>} Returns closed {@link Device} when operation is successful.\n   */\n  cancelConnection(): Promise<Device> {\n    return this._manager.cancelDeviceConnection(this.id)\n  }\n\n  /**\n   * {@link #blemanagerisdeviceconnected|bleManager.isDeviceConnected()} with partially filled arguments.\n   *\n   * @returns {Promise<boolean>} Promise which emits `true` if device is connected, and `false` otherwise.\n   */\n  isConnected(): Promise<boolean> {\n    return this._manager.isDeviceConnected(this.id)\n  }\n\n  /**\n   * {@link #blemanagerondevicedisconnected|bleManager.onDeviceDisconnected()} with partially filled arguments.\n   *\n   * @param {function(error: ?BleError, device: Device)} listener callback returning error as a reason of disconnection\n   * if available and {@link Device} object. If an error is null, that means the connection was terminated by\n   * {@link #blemanagercanceldeviceconnection|bleManager.cancelDeviceConnection()} call.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  onDisconnected(listener: (error: ?BleError, device: Device) => void): Subscription {\n    return this._manager.onDeviceDisconnected(this.id, listener)\n  }\n\n  /**\n   * {@link #blemanagerdiscoverallservicesandcharacteristicsfordevice|bleManager.discoverAllServicesAndCharacteristicsForDevice()} with partially filled arguments.\n   *\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Device>} Promise which emits {@link Device} object if all available services and\n   * characteristics have been discovered.\n   */\n  discoverAllServicesAndCharacteristics(transactionId: ?TransactionId): Promise<Device> {\n    return this._manager.discoverAllServicesAndCharacteristicsForDevice(this.id, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerservicesfordevice|bleManager.servicesForDevice()} with partially filled arguments.\n   *\n   * @returns {Promise<Service[]>} Promise which emits array of {@link Service} objects which are discovered by this\n   * device.\n   */\n  services(): Promise<Service[]> {\n    return this._manager.servicesForDevice(this.id)\n  }\n\n  /**\n   * {@link #blemanagercharacteristicsfordevice|bleManager.characteristicsForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @returns {Promise<Characteristic[]>} Promise which emits array of {@link Characteristic} objects which are\n   * discovered for a {@link Device} in specified {@link Service}.\n   */\n  characteristicsForService(serviceUUID: string): Promise<Characteristic[]> {\n    return this._manager.characteristicsForDevice(this.id, serviceUUID)\n  }\n\n  /**\n   * {@link #blemanagerdescriptorsfordevice|bleManager.descriptorsForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered for this {@link Characteristic}.\n   */\n  descriptorsForService(serviceUUID: UUID, characteristicUUID: UUID): Promise<Array<Descriptor>> {\n    return this._manager.descriptorsForDevice(this.id, serviceUUID, characteristicUUID)\n  }\n\n  /**\n   * {@link #blemanagerreadcharacteristicfordevice|bleManager.readCharacteristicForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of {@link Characteristic} will be stored inside returned object.\n   */\n  readCharacteristicForService(\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    return this._manager.readCharacteristicForDevice(this.id, serviceUUID, characteristicUUID, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritecharacteristicwithresponsefordevice|bleManager.writeCharacteristicWithResponseForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} valueBase64 Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of characteristic may not be stored inside returned object.\n   */\n  writeCharacteristicWithResponseForService(\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    return this._manager.writeCharacteristicWithResponseForDevice(\n      this.id,\n      serviceUUID,\n      characteristicUUID,\n      valueBase64,\n      transactionId\n    )\n  }\n\n  /**\n   * {@link #blemanagerwritecharacteristicwithoutresponsefordevice|bleManager.writeCharacteristicWithoutResponseForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} valueBase64 Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of characteristic may not be stored inside returned object.\n   */\n  writeCharacteristicWithoutResponseForService(\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    return this._manager.writeCharacteristicWithoutResponseForDevice(\n      this.id,\n      serviceUUID,\n      characteristicUUID,\n      valueBase64,\n      transactionId\n    )\n  }\n\n  /**\n   * {@link #blemanagermonitorcharacteristicfordevice|bleManager.monitorCharacteristicForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener - callback which emits\n   * {@link Characteristic} objects with modified value for each notification.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  monitorCharacteristicForService(\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void,\n    transactionId: ?TransactionId\n  ): Subscription {\n    return this._manager.monitorCharacteristicForDevice(\n      this.id,\n      serviceUUID,\n      characteristicUUID,\n      listener,\n      transactionId\n    )\n  }\n\n  /**\n   * {@link #blemanagerreaddescriptorfordevice|bleManager.readDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {UUID} descriptorUUID {@link Descriptor} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   */\n  async readDescriptorForService(\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    return this._manager.readDescriptorForDevice(\n      this.id,\n      serviceUUID,\n      characteristicUUID,\n      descriptorUUID,\n      transactionId\n    )\n  }\n\n  /**\n   * {@link #blemanagerwritedescriptorfordevice|bleManager.writeDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value.\n   */\n  async writeDescriptorForService(\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    return this._manager.writeDescriptorForDevice(\n      this.id,\n      serviceUUID,\n      characteristicUUID,\n      descriptorUUID,\n      valueBase64,\n      transactionId\n    )\n  }\n}\n","// @flow\n'use strict'\n\nimport type { BleManager } from './BleManager'\nimport type { BleError } from './BleError'\nimport type { Characteristic } from './Characteristic'\nimport type { Descriptor } from './Descriptor'\nimport type { NativeService } from './BleModule'\nimport type { DeviceId, Identifier, Base64, UUID, Subscription, TransactionId } from './TypeDefinition'\n\n/**\n * Service object.\n */\nexport class Service implements NativeService {\n  /**\n   * Internal BLE Manager handle\n   * @private\n   */\n  _manager: BleManager\n  /**\n   * Service unique identifier\n   */\n  id: Identifier\n  /**\n   * Service UUID\n   */\n  uuid: UUID\n  /**\n   * Device's ID to which service belongs\n   */\n  deviceID: DeviceId\n  /**\n   * Value indicating whether the type of service is primary or secondary.\n   */\n  isPrimary: boolean\n\n  /**\n   * Private constructor used to create {@link Service} object.\n   *\n   * @param {NativeService} nativeService NativeService properties to be copied.\n   * @param {BleManager} manager Current BleManager instance.\n   * @private\n   * @ignore\n   */\n  constructor(nativeService: NativeService, manager: BleManager) {\n    Object.assign(this, nativeService, { _manager: manager })\n  }\n\n  /**\n   * {@link #blemanagercharacteristicsfordevice|bleManager.characteristicsForDevice()} with partially filled arguments.\n   *\n   * @returns {Promise<Array<Characteristic>>} Promise which emits array of {@link Characteristic} objects which are\n   * discovered for this service.\n   */\n  characteristics(): Promise<Array<Characteristic>> {\n    return this._manager._characteristicsForService(this.id)\n  }\n\n  /**\n   * {@link #blemanagerdescriptorsfordevice|bleManager.descriptorsForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered for this {@link Service} in specified {@link Characteristic}.\n   */\n  descriptorsForCharacteristic(characteristicUUID: UUID): Promise<Array<Descriptor>> {\n    return this._manager._descriptorsForService(this.id, characteristicUUID)\n  }\n\n  /**\n   * {@link #blemanagerreadcharacteristicfordevice|bleManager.readCharacteristicForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID path. Latest value of {@link Characteristic} will be stored inside returned object.\n   */\n  readCharacteristic(characteristicUUID: UUID, transactionId: ?TransactionId): Promise<Characteristic> {\n    return this._manager._readCharacteristicForService(this.id, characteristicUUID, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritecharacteristicwithresponsefordevice|bleManager.writeCharacteristicWithResponseForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} valueBase64 Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID path. Latest value of characteristic may not be stored inside returned object.\n   */\n  writeCharacteristicWithResponse(\n    characteristicUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    return this._manager._writeCharacteristicWithResponseForService(\n      this.id,\n      characteristicUUID,\n      valueBase64,\n      transactionId\n    )\n  }\n\n  /**\n   * {@link #blemanagerwritecharacteristicwithoutresponsefordevice|bleManager.writeCharacteristicWithoutResponseForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} valueBase64 Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID path. Latest value of characteristic may not be stored inside returned object.\n   */\n  writeCharacteristicWithoutResponse(\n    characteristicUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    return this._manager._writeCharacteristicWithoutResponseForService(\n      this.id,\n      characteristicUUID,\n      valueBase64,\n      transactionId\n    )\n  }\n\n  /**\n   * {@link #blemanagermonitorcharacteristicfordevice|bleManager.monitorCharacteristicForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID - {@link Characteristic} UUID.\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener callback which emits\n   * {@link Characteristic} objects with modified value for each notification.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  monitorCharacteristic(\n    characteristicUUID: UUID,\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void,\n    transactionId: ?TransactionId\n  ): Subscription {\n    return this._manager._monitorCharacteristicForService(this.id, characteristicUUID, listener, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerreaddescriptorfordevice|bleManager.readDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {UUID} descriptorUUID {@link Descriptor} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   */\n  async readDescriptorForCharacteristic(\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    return this._manager._readDescriptorForService(this.id, characteristicUUID, descriptorUUID, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritedescriptorfordevice|bleManager.writeDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value.\n   */\n  async writeDescriptorForCharacteristic(\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    return this._manager._writeDescriptorForService(\n      this.id,\n      characteristicUUID,\n      descriptorUUID,\n      valueBase64,\n      transactionId\n    )\n  }\n}\n","// @flow\n'use strict'\n\nimport type { BleManager } from './BleManager'\nimport type { NativeDescriptor } from './BleModule'\nimport type { DeviceId, Identifier, UUID, TransactionId, Base64 } from './TypeDefinition'\n\n/**\n * Descriptor object.\n */\nexport class Descriptor implements NativeDescriptor {\n  /**\n   * Internal BLE Manager handle\n   * @private\n   */\n  _manager: BleManager\n  /**\n   * Descriptor unique identifier\n   */\n  id: Identifier\n  /**\n   * Descriptor UUID\n   */\n  uuid: UUID\n  /**\n   * Characteristic's ID to which descriptor belongs\n   */\n  characteristicID: Identifier\n  /**\n   * Characteristic's UUID to which descriptor belongs\n   */\n  characteristicUUID: UUID\n  /**\n   * Service's ID to which descriptor belongs\n   */\n  serviceID: Identifier\n  /**\n   * Service's UUID to which descriptor belongs\n   */\n  serviceUUID: UUID\n  /**\n   * Device's ID to which descriptor belongs\n   */\n  deviceID: DeviceId\n  /**\n   * Descriptor value if present\n   */\n  value: ?Base64\n\n  /**\n   * Private constructor used to create instance of {@link Descriptor}.\n   * @param {NativeDescriptor} nativeDescriptor NativeDescriptor\n   * @param {BleManager} manager BleManager\n   * @private\n   */\n  constructor(nativeDescriptor: NativeDescriptor, manager: BleManager) {\n    Object.assign(this, nativeDescriptor, { _manager: manager })\n  }\n\n  /**\n   * {@link #blemanagerreaddescriptorfordevice|bleManager.readDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   */\n  async read(transactionId: ?TransactionId): Promise<Descriptor> {\n    return this._manager._readDescriptor(this.id, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritedescriptorfordevice|bleManager.writeDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value.\n   */\n  async write(valueBase64: Base64, transactionId: ?TransactionId): Promise<Descriptor> {\n    return this._manager._writeDescriptor(this.id, valueBase64, transactionId)\n  }\n}\n","// @flow\n'use strict'\n\nimport type { BleManager } from './BleManager'\nimport type { BleError } from './BleError'\nimport { Descriptor } from './Descriptor'\nimport type { NativeCharacteristic } from './BleModule'\nimport type { DeviceId, Identifier, UUID, TransactionId, Base64, Subscription } from './TypeDefinition'\n\n/**\n * Characteristic object.\n */\nexport class Characteristic implements NativeCharacteristic {\n  /**\n   * Internal BLE Manager handle\n   * @private\n   */\n  _manager: BleManager\n  /**\n   * Characteristic unique identifier\n   */\n  id: Identifier\n  /**\n   * Characteristic UUID\n   */\n  uuid: UUID\n  /**\n   * Service's ID to which characteristic belongs\n   */\n  serviceID: Identifier\n  /**\n   * Service's UUID to which characteristic belongs\n   */\n  serviceUUID: UUID\n  /**\n   * Device's ID to which characteristic belongs\n   */\n  deviceID: DeviceId\n  /**\n   * True if characteristic can be read\n   */\n  isReadable: boolean\n  /**\n   * True if characteristic can be written with response\n   */\n  isWritableWithResponse: boolean\n  /**\n   * True if characteristic can be written without response\n   */\n  isWritableWithoutResponse: boolean\n  /**\n   * True if characteristic can monitor value changes.\n   */\n  isNotifiable: boolean\n  /**\n   * True if characteristic is monitoring value changes without ACK.\n   */\n  isNotifying: boolean\n  /**\n   * True if characteristic is monitoring value changes with ACK.\n   */\n  isIndicatable: boolean\n  /**\n   * Characteristic value if present\n   */\n  value: ?Base64\n\n  /**\n   * Private constructor used to create instance of {@link Characteristic}.\n   * @param {NativeCharacteristic} nativeCharacteristic NativeCharacteristic\n   * @param {BleManager} manager BleManager\n   * @private\n   */\n  constructor(nativeCharacteristic: NativeCharacteristic, manager: BleManager) {\n    Object.assign(this, nativeCharacteristic, { _manager: manager })\n  }\n\n  /**\n   * {@link #blemanagerdescriptorsfordevice|bleManager.descriptorsForDevice()} with partially filled arguments.\n   *\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered for this {@link Characteristic}.\n   */\n  descriptors(): Promise<Array<Descriptor>> {\n    return this._manager._descriptorsForCharacteristic(this.id)\n  }\n\n  /**\n   * {@link #blemanagerreadcharacteristicfordevice|bleManager.readCharacteristicForDevice()} with partially filled arguments.\n   *\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits this {@link Characteristic}. Latest value will be stored\n   * inside returned object.\n   */\n  read(transactionId: ?TransactionId): Promise<Characteristic> {\n    return this._manager._readCharacteristic(this.id, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritecharacteristicwithresponsefordevice|bleManager.writeCharacteristicWithResponseForDevice()} with partially filled arguments.\n   *\n   * @param {Base64} valueBase64 Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits this {@link Characteristic}. Latest value may\n   * not be stored inside returned object.\n   */\n  writeWithResponse(valueBase64: Base64, transactionId: ?TransactionId): Promise<Characteristic> {\n    return this._manager._writeCharacteristicWithResponse(this.id, valueBase64, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritecharacteristicwithoutresponsefordevice|bleManager.writeCharacteristicWithoutResponseForDevice()} with partially filled arguments.\n   *\n   * @param {Base64} valueBase64 Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits this {@link Characteristic}. Latest value may\n   * not be stored inside returned object.\n   */\n  writeWithoutResponse(valueBase64: Base64, transactionId: ?TransactionId): Promise<Characteristic> {\n    return this._manager._writeCharacteristicWithoutResponse(this.id, valueBase64, transactionId)\n  }\n\n  /**\n   * {@link #blemanagermonitorcharacteristicfordevice|bleManager.monitorCharacteristicForDevice()} with partially filled arguments.\n   *\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener callback which emits\n   * this {@link Characteristic} with modified value for each notification.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|bleManager.cancelTransaction()} function.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  monitor(\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void,\n    transactionId: ?TransactionId\n  ): Subscription {\n    return this._manager._monitorCharacteristic(this.id, listener, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerreaddescriptorfordevice|bleManager.readDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} descriptorUUID {@link Descriptor} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   */\n  async readDescriptor(descriptorUUID: UUID, transactionId: ?TransactionId): Promise<Descriptor> {\n    return this._manager._readDescriptorForCharacteristic(this.id, descriptorUUID, transactionId)\n  }\n\n  /**\n   * {@link #blemanagerwritedescriptorfordevice|bleManager.writeDescriptorForDevice()} with partially filled arguments.\n   *\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value.\n   */\n  async writeDescriptor(descriptorUUID: UUID, valueBase64: Base64, transactionId: ?TransactionId): Promise<Descriptor> {\n    return this._manager._writeDescriptorForCharacteristic(this.id, descriptorUUID, valueBase64, transactionId)\n  }\n}\n","// @flow\n'use strict'\n\nimport { NativeModules, NativeEventEmitter } from 'react-native'\nimport { State, LogLevel, ConnectionPriority } from './TypeDefinition'\nimport type {\n  DeviceId,\n  Identifier,\n  UUID,\n  TransactionId,\n  Base64,\n  ScanOptions,\n  ConnectionOptions\n} from './TypeDefinition'\n\n/**\n * Native device object passed from BleModule.\n * @private\n */\nexport interface NativeDevice {\n  /**\n   * Device identifier: MAC address on Android and UUID on iOS.\n   * @private\n   */\n  id: DeviceId;\n  /**\n   * Device name if present\n   * @private\n   */\n  name: ?string;\n  /**\n   * Current Received Signal Strength Indication of device\n   * @private\n   */\n  rssi: ?number;\n  /**\n   * Current Maximum Transmission Unit for this device. When device is not connected\n   * default value of 23 is used.\n   * @private\n   */\n  mtu: number;\n\n  // Advertisement\n\n  /**\n   * Device's custom manufacturer data. Its format is defined by manufacturer.\n   * @private\n   */\n  manufacturerData: ?Base64;\n\n  /**\n   * Map od service UUIDs with associated data.\n   * @private\n   */\n  serviceData: ?{ [uuid: UUID]: Base64 };\n\n  /**\n   * List of available services visible during scanning.\n   * @private\n   */\n  serviceUUIDs: ?Array<UUID>;\n\n  /**\n   * User friendly name of device.\n   * @private\n   */\n  localName: ?string;\n\n  /**\n   * Transmission power level of device.\n   * @private\n   */\n  txPowerLevel: ?number;\n\n  /**\n   * List of solicited service UUIDs.\n   * @private\n   */\n  solicitedServiceUUIDs: ?Array<UUID>;\n\n  /**\n   * Is device connectable.\n   * @private\n   */\n  isConnectable: ?boolean;\n\n  /**\n   * List of overflow service UUIDs.\n   * @private\n   */\n  overflowServiceUUIDs: ?Array<UUID>;\n}\n\n/**\n * Native service object passed from BleModule.\n * @private\n */\nexport interface NativeService {\n  /**\n   * Service unique identifier\n   * @private\n   */\n  id: Identifier;\n  /**\n   * Service UUID\n   * @private\n   */\n  uuid: UUID;\n  /**\n   * Device's ID to which service belongs\n   * @private\n   */\n  deviceID: DeviceId;\n  /**\n   * Value indicating whether the type of service is primary or secondary.\n   * @private\n   */\n  isPrimary: boolean;\n}\n\n/**\n * Native characteristic object passed from BleModule.\n * @private\n */\nexport interface NativeCharacteristic {\n  /**\n   * Characteristic unique identifier\n   * @private\n   */\n  id: Identifier;\n  /**\n   * Characteristic UUID\n   * @private\n   */\n  uuid: UUID;\n  /**\n   * Service's ID to which characteristic belongs\n   * @private\n   */\n  serviceID: Identifier;\n  /**\n   * Service's UUID to which characteristic belongs\n   * @private\n   */\n  serviceUUID: UUID;\n  /**\n   * Device's ID to which characteristic belongs\n   * @private\n   */\n  deviceID: DeviceId;\n  /**\n   * True if characteristic can be read\n   * @private\n   */\n  isReadable: boolean;\n  /**\n   * True if characteristic can be written with response\n   * @private\n   */\n  isWritableWithResponse: boolean;\n  /**\n   * True if characteristic can be written without response\n   * @private\n   */\n  isWritableWithoutResponse: boolean;\n  /**\n   * True if characteristic can monitor value changes.\n   * @private\n   */\n  isNotifiable: boolean;\n  /**\n   * True if characteristic is monitoring value changes without ACK.\n   * @private\n   */\n  isNotifying: boolean;\n  /**\n   * True if characteristic is monitoring value changes with ACK.\n   * @private\n   */\n  isIndicatable: boolean;\n  /**\n   * Characteristic value if present\n   * @private\n   */\n  value: ?Base64;\n}\n\n/**\n * Native descriptor object passed from BleModule.\n * @private\n */\nexport interface NativeDescriptor {\n  /**\n   * Descriptor unique identifier\n   * @private\n   */\n  id: Identifier;\n  /**\n   * Descriptor UUID\n   * @private\n   */\n  uuid: UUID;\n  /**\n   * Characteristic's ID to which descriptor belongs\n   * @private\n   */\n  characteristicID: Identifier;\n  /**\n   * Characteristic's UUID to which descriptor belongs\n   * @private\n   */\n  characteristicUUID: UUID;\n  /**\n   * Service's ID to which descriptor belongs\n   * @private\n   */\n  serviceID: Identifier;\n  /**\n   * Service's UUID to which descriptor belongs\n   * @private\n   */\n  serviceUUID: UUID;\n  /**\n   * Device's ID to which descriptor belongs\n   * @private\n   */\n  deviceID: DeviceId;\n  /**\n   * Descriptor value if present\n   * @private\n   */\n  value: ?Base64;\n}\n\n/**\n * Object representing information about restored BLE state after application relaunch.\n * @private\n */\nexport interface NativeBleRestoredState {\n  /**\n   * List of connected devices after state restoration.\n   * @type {Array<NativeDevice>}\n   * @instance\n   * @memberof NativeBleRestoredState\n   * @private\n   */\n  connectedPeripherals: Array<NativeDevice>;\n}\n\n/**\n * Native BLE Module interface\n * @private\n */\nexport interface BleModuleInterface {\n  // NativeModule methods\n\n  addListener(string): void;\n  removeListeners(number): void;\n\n  // Lifecycle\n\n  /**\n   * Creates new native module internally. Only one module\n   * is allowed to be instantiated.\n   * @param {?string} restoreIdentifierKey Optional unique Id used for state restoration of BLE manager.\n   * @private\n   */\n  createClient(restoreIdentifierKey: ?string): void;\n\n  /**\n   * Destroys previously instantiated module. This function is\n   * only safe when previously BleModule was created.\n   * @private\n   */\n  destroyClient(): void;\n\n  // Monitoring state\n\n  /**\n   * Enable Bluetooth. This function blocks until BLE is in PoweredOn state. [Android only]\n   *\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<void>} Promise completes when state transition was successful.\n   * @private\n   */\n  enable(transactionId: TransactionId): Promise<void>;\n\n  /**\n   * Disable Bluetooth. This function blocks until BLE is in PoweredOff state. [Android only]\n   *\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<void>} Promise completes when state transition was successful.\n   * @private\n   */\n  disable(transactionId: TransactionId): Promise<void>;\n\n  /**\n   * Current state of BLE device.\n   *\n   * @returns {Promise<State>} Current state of BLE device.\n   * @private\n   */\n  state(): Promise<$Keys<typeof State>>;\n\n  // Scanning\n\n  /**\n   * Starts device scan.\n   *\n   * @param {?Array<UUID>} filteredUUIDs List of UUIDs for services which needs to be present to detect device during\n   * scanning.\n   * @param {?ScanOptions} options Platform dependent options\n   * @private\n   */\n  startDeviceScan(filteredUUIDs: ?Array<UUID>, options: ?ScanOptions): void;\n\n  /**\n   * Stops device scan.\n   * @private\n   */\n  stopDeviceScan(): void;\n\n  // Device operations\n\n  /**\n   * Request a connection parameter update. This functions may update connection parameters on Android API level 21 or\n   * above.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @param {ConnectionPriority} connectionPriority: Connection priority.\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation.\n   * @returns {Promise<NativeDevice>} Connected device.\n   * @private\n   */\n  requestConnectionPriorityForDevice(\n    deviceIdentifier: DeviceId,\n    connectionPriority: $Values<typeof ConnectionPriority>,\n    transactionId: TransactionId\n  ): Promise<NativeDevice>;\n\n  /**\n   * Reads RSSI for connected device.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDevice>} Connected device with updated RSSI value.\n   * @private\n   */\n  readRSSIForDevice(deviceIdentifier: DeviceId, transactionId: TransactionId): Promise<NativeDevice>;\n\n  /**\n   * Request new MTU value for this device. This function currently is not doing anything\n   * on iOS platform as MTU exchange is done automatically.\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @param {number} mtu New MTU to negotiate.\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDevice>} Device with updated MTU size. Default value is 23.\n   * @private\n   */\n  requestMTUForDevice(deviceIdentifier: DeviceId, mtu: number, transactionId: TransactionId): Promise<NativeDevice>;\n\n  // Device management\n\n  /**\n   * Returns a list of known peripherals by their identifiers.\n   * @param {Array<DeviceId>} deviceIdentifiers List of device identifiers\n   * @returns {Promise<Array<NativeDevice>>} List of known devices by their identifiers.\n   * @private\n   */\n  devices(deviceIdentifiers: Array<DeviceId>): Promise<Array<NativeDevice>>;\n\n  /**\n   * Returns a list of the peripherals (containing any of the specified services) currently connected to the system\n   * which have discovered services. Returned devices **may not be connected** to your application.\n   * @param {Array<UUID>} serviceUUIDs List of service UUIDs. Device must contain at least one of them to be listed.\n   * @returns {Promise<Array<NativeDevice>>} List of known devices with discovered services as stated in the parameter.\n   * @private\n   */\n  connectedDevices(serviceUUIDs: Array<UUID>): Promise<Array<NativeDevice>>;\n\n  // Connection management\n\n  /**\n   * Connect to specified device.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier to connect to.\n   * @param {?ConnectionOptions} options Connection options.\n   * @returns {Promise<NativeDevice>} Connected device.\n   * @private\n   */\n  connectToDevice(deviceIdentifier: DeviceId, options: ?ConnectionOptions): Promise<NativeDevice>;\n\n  /**\n   * Cancels pending device connection.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier which is already connected.\n   * @returns {Promise<NativeDevice>} Disconnected device.\n   * @private\n   */\n  cancelDeviceConnection(deviceIdentifier: DeviceId): Promise<NativeDevice>;\n\n  /**\n   * Checks if specified device is connected.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @returns {Promise<boolean>} True if specified device is connected.\n   * @private\n   */\n  isDeviceConnected(deviceIdentifier: DeviceId): Promise<boolean>;\n\n  // Discovery\n\n  /**\n   * Discovers all services, characteristics and descriptors for specified device.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier.\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDevice>} Device which has discovered characteristics and services.\n   * @private\n   */\n  discoverAllServicesAndCharacteristicsForDevice(\n    deviceIdentifier: DeviceId,\n    transactionId: TransactionId\n  ): Promise<NativeDevice>;\n\n  // Service and characteristic getters\n\n  /**\n   * List of discovered services for specified device.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier.\n   * @returns {Promise<Array<NativeService>>} List of services available in device.\n   * @private\n   */\n  servicesForDevice(deviceIdentifier: DeviceId): Promise<Array<NativeService>>;\n\n  /**\n   * List of discovered characteristics for specified service.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier.\n   * @param {UUID} serviceUUID Service UUID which contains characteristics.\n   * @returns {Promise<Array<NativeCharacteristic>>} List of characteristics available in service.\n   * @private\n   */\n  characteristicsForDevice(deviceIdentifier: DeviceId, serviceUUID: UUID): Promise<Array<NativeCharacteristic>>;\n\n  /**\n   * List of discovered characteristics for specified service.\n   *\n   * @param {Identifier} serviceIdentifier Service ID which contains characteristics.\n   * @returns {Promise<Array<NativeCharacteristic>>} List of characteristics available in service.\n   * @private\n   */\n  characteristicsForService(serviceIdentifier: Identifier): Promise<Array<NativeCharacteristic>>;\n\n  /**\n   * List of discovered descriptors for specified characteristic.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier.\n   * @param {UUID} serviceUUID Service UUID which contains descriptors.\n   * @param {UUID} characteristicUUID Characteristic UUID which contains descriptors.\n   * @returns {Promise<Array<NativeDescriptor>>} List of descriptors available in characteristic.\n   * @private\n   */\n  descriptorsForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID\n  ): Promise<Array<NativeDescriptor>>;\n\n  /**\n   * List of discovered descriptors for specified characteristic.\n   *\n   * @param {Identifier} serviceIdentifier Service identifier which contains descriptors.\n   * @param {UUID} characteristicUUID Characteristic UUID which contains descriptors.\n   * @returns {Promise<Array<NativeDescriptor>>} List of descriptors available in characteristic.\n   * @private\n   */\n  descriptorsForService(serviceIdentifier: Identifier, characteristicUUID: UUID): Promise<Array<NativeDescriptor>>;\n\n  /**\n   * List of discovered descriptors for specified characteristic.\n   *\n   * @param {Identifier} characteristicIdentifier Characteristic identifier which contains descriptors.\n   * @returns {Promise<Array<NativeDescriptor>>} List of descriptors available in characteristic.\n   * @private\n   */\n  descriptorsForCharacteristic(characteristicIdentifier: Identifier): Promise<Array<NativeDescriptor>>;\n\n  // Characteristics operations\n\n  /**\n   * Read characteristic's value.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier\n   * @param {UUID} serviceUUID Service UUID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeCharacteristic>} Characteristic for which value was read\n   * @private\n   */\n  readCharacteristicForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<NativeCharacteristic>;\n\n  /**\n   * Read characteristic's value.\n   *\n   * @param {Identifier} serviceIdentifier Service ID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeCharacteristic>} Characteristic for which value was read\n   * @private\n   */\n  readCharacteristicForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<NativeCharacteristic>;\n\n  /**\n   * Read characteristic's value.\n   *\n   * @param {Identifier} characteristicIdentifer Characteristic ID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeCharacteristic>} Characteristic for which value was read\n   * @private\n   */\n  readCharacteristic(characteristicIdentifer: Identifier, transactionId: TransactionId): Promise<NativeCharacteristic>;\n\n  /**\n   * Write value to characteristic.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier\n   * @param {UUID} serviceUUID Service UUID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {boolean} withResponse True if write should be with response\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeCharacteristic>} Characteristic which saved passed value\n   * @private\n   */\n  writeCharacteristicForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    valueBase64: Base64,\n    withResponse: boolean,\n    transactionId: TransactionId\n  ): Promise<NativeCharacteristic>;\n\n  /**\n   * Write value to characteristic.\n   *\n   * @param {Identifier} serviceIdentifier Service ID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {boolean} withResponse True if write should be with response\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeCharacteristic>} Characteristic which saved passed value\n   * @private\n   */\n  writeCharacteristicForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    valueBase64: Base64,\n    withResponse: boolean,\n    transactionId: TransactionId\n  ): Promise<NativeCharacteristic>;\n\n  /**\n   * Write value to characteristic.\n   *\n   * @param {Identifier} characteristicIdentifier Characteristic ID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {boolean} withResponse True if write should be with response\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeCharacteristic>} Characteristic which saved passed value\n   * @private\n   */\n  writeCharacteristic(\n    characteristicIdentifier: Identifier,\n    valueBase64: Base64,\n    withResponse: boolean,\n    transactionId: TransactionId\n  ): Promise<NativeCharacteristic>;\n\n  /**\n   * Setup monitoring of characteristic value.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier\n   * @param {UUID} serviceUUID Service UUID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<void>} Value which is returned when monitoring was cancelled or resulted in error\n   * @private\n   */\n  monitorCharacteristicForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<void>;\n\n  /**\n   * Setup monitoring of characteristic value.\n   *\n   * @param {Identifier} serviceIdentifier Service ID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<void>} Value which is returned when monitoring was cancelled or resulted in error\n   * @private\n   */\n  monitorCharacteristicForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<void>;\n\n  /**\n   * Setup monitoring of characteristic value.\n   *\n   * @param {Identifier} characteristicIdentifier Characteristic ID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<void>} Value which is returned when monitoring was cancelled or resulted in error\n   * @private\n   */\n  monitorCharacteristic(characteristicIdentifier: Identifier, transactionId: TransactionId): Promise<void>;\n\n  // Descriptor operations\n\n  /**\n   * Read descriptor's value.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier\n   * @param {UUID} serviceUUID Service UUID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor for which value was read\n   * @private\n   */\n  readDescriptorForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  /**\n   * Read descriptor's value.\n   *\n   * @param {Identifier} serviceIdentifier Service identifier\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor for which value was read\n   * @private\n   */\n  readDescriptorForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  /**\n   * Read descriptor's value.\n   *\n   * @param {Identifier} characteristicIdentifier Characteristic identifier\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor for which value was read\n   * @private\n   */\n  readDescriptorForCharacteristic(\n    characteristicIdentifier: Identifier,\n    descriptorUUID: UUID,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  /**\n   * Read descriptor's value.\n   *\n   * @param {Identifier} descriptorIdentifier Descriptor identifier\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor for which value was read\n   * @private\n   */\n  readDescriptor(descriptorIdentifier: Identifier, transactionId: TransactionId): Promise<NativeDescriptor>;\n\n  /**\n   * Write value to descriptor.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier\n   * @param {UUID} serviceUUID Service UUID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor which saved passed value\n   * @private\n   */\n  writeDescriptorForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  /**\n   * Write value to descriptor.\n   *\n   * @param {Identifier} serviceIdentifier Service identifier\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor which saved passed value\n   * @private\n   */\n  writeDescriptorForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  /**\n   * Write value to descriptor.\n   *\n   * @param {Identifier} characteristicIdentifier Characteristic identifier\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor which saved passed value\n   * @private\n   */\n  writeDescriptorForCharacteristic(\n    characteristicIdentifier: Identifier,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  /**\n   * Write value to descriptor.\n   *\n   * @param {Identifier} descriptorIdentifier Descriptor identifier\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<NativeDescriptor>} Descriptor which saved passed value\n   * @private\n   */\n  writeDescriptor(\n    descriptorIdentifier: Identifier,\n    valueBase64: Base64,\n    transactionId: TransactionId\n  ): Promise<NativeDescriptor>;\n\n  // Other APIs\n\n  /**\n   * Cancels specified transaction\n   *\n   * @param {TransactionId} transactionId Transaction handle for operation to be cancelled\n   * @private\n   */\n  cancelTransaction(transactionId: TransactionId): void;\n\n  /**\n   * Sets new log level for native module's logging mechanism.\n   * @param {LogLevel} logLevel New log level to be set.\n   * @private\n   */\n  setLogLevel(logLevel: $Keys<typeof LogLevel>): void;\n\n  /**\n   * Get current log level for native module's logging mechanism.\n   * @returns {Promise<LogLevel>} Current log level.\n   * @private\n   */\n  logLevel(): Promise<$Keys<typeof LogLevel>>;\n\n  // Events\n\n  /**\n   * New scanned event arrived as [?Error, ?NativeDevice] object.\n   * @private\n   */\n  ScanEvent: string;\n\n  /**\n   * Characteristic value update broadcasted due to registered notification as\n   * [?Error, ?NativeCharacteristic, ?TransactionId].\n   * @private\n   */\n  ReadEvent: string;\n\n  /**\n   * BLE Manager changed its state as $Keys<typeof State>\n   * @private\n   */\n  StateChangeEvent: string;\n\n  /**\n   * BLE Manager restored its internal state\n   * @private\n   */\n  RestoreStateEvent: string;\n\n  /**\n   * Device disconnected as [Error?, NativeDevice]\n   * @private\n   */\n  DisconnectionEvent: string;\n}\n\nexport const BleModule: BleModuleInterface = NativeModules.BleClientManager\nexport const EventEmitter = NativeEventEmitter\n","// @flow\n'use strict'\n\nimport { Device } from './Device'\nimport { Service } from './Service'\nimport { Characteristic } from './Characteristic'\nimport { Descriptor } from './Descriptor'\nimport { State, LogLevel, type BleErrorCodeMessageMapping, ConnectionPriority } from './TypeDefinition'\nimport { BleModule, EventEmitter } from './BleModule'\nimport {\n  parseBleError,\n  BleError,\n  BleErrorCode,\n  BleErrorCodeMessage,\n  BleATTErrorCode,\n  BleAndroidErrorCode,\n  BleIOSErrorCode\n} from './BleError'\nimport type { NativeDevice, NativeCharacteristic, NativeDescriptor, NativeBleRestoredState } from './BleModule'\nimport type {\n  Subscription,\n  DeviceId,\n  Identifier,\n  UUID,\n  TransactionId,\n  Base64,\n  ScanOptions,\n  ConnectionOptions,\n  BleManagerOptions\n} from './TypeDefinition'\n\n/**\n *\n * BleManager is an entry point for react-native-ble-plx library. It provides all means to discover and work with\n * {@link Device} instances. It should be initialized only once with `new` keyword and method\n * {@link #blemanagerdestroy|destroy()} should be called on its instance when user wants to deallocate all resources.\n *\n * In case you want to properly support Background Mode, you should provide `restoreStateIdentifier` and\n * `restoreStateFunction` in {@link BleManagerOptions}.\n *\n * @example\n * const manager = new BleManager();\n * // ... work with BLE manager ...\n * manager.destroy();\n */\nexport class BleManager {\n  // Scan subscriptions\n  _scanEventSubscription: ?EventEmitter\n  // Listening to BleModule events\n  _eventEmitter: EventEmitter\n  // Unique identifier used to create internal transactionIds\n  _uniqueId: number\n  // Map of active promises with functions to forcibly cancel them\n  _activePromises: { [id: string]: (error: BleError) => void }\n  // Map of active subscriptions\n  _activeSubscriptions: { [id: string]: Subscription }\n\n  // Map of error codes to error messages\n  _errorCodesToMessagesMapping: BleErrorCodeMessageMapping\n\n  /**\n   * Creates an instance of {@link BleManager}.\n   */\n  constructor(options: BleManagerOptions = {}) {\n    this._eventEmitter = new EventEmitter(BleModule)\n    this._uniqueId = 0\n    this._activePromises = {}\n    this._activeSubscriptions = {}\n\n    const restoreStateFunction = options.restoreStateFunction\n    if (restoreStateFunction != null && options.restoreStateIdentifier != null) {\n      this._activeSubscriptions[this._nextUniqueID()] = this._eventEmitter.addListener(\n        BleModule.RestoreStateEvent,\n        (nativeRestoredState: NativeBleRestoredState) => {\n          if (nativeRestoredState == null) {\n            restoreStateFunction(null)\n            return\n          }\n          restoreStateFunction({\n            connectedPeripherals: nativeRestoredState.connectedPeripherals.map(\n              nativeDevice => new Device(nativeDevice, this)\n            )\n          })\n        }\n      )\n    }\n\n    this._errorCodesToMessagesMapping = options.errorCodesToMessagesMapping\n      ? options.errorCodesToMessagesMapping\n      : BleErrorCodeMessage\n\n    BleModule.createClient(options.restoreStateIdentifier || null)\n  }\n\n  /**\n   * Destroys all promises which are in progress.\n   * @private\n   */\n  _destroyPromises() {\n    const destroyedError = new BleError(\n      {\n        errorCode: BleErrorCode.BluetoothManagerDestroyed,\n        attErrorCode: (null: ?$Values<typeof BleATTErrorCode>),\n        iosErrorCode: (null: ?$Values<typeof BleIOSErrorCode>),\n        androidErrorCode: (null: ?$Values<typeof BleAndroidErrorCode>),\n        reason: (null: ?string)\n      },\n      this._errorCodesToMessagesMapping\n    )\n    for (const id in this._activePromises) {\n      this._activePromises[id](destroyedError)\n    }\n  }\n\n  /**\n   * Destroys all subscriptions.\n   * @private\n   */\n  _destroySubscriptions() {\n    for (const id in this._activeSubscriptions) {\n      this._activeSubscriptions[id].remove()\n    }\n  }\n\n  /**\n   * Destroys {@link BleManager} instance. A new instance needs to be created to continue working with\n   * this library. All operations which were in progress completes with\n   * {@link #bleerrorcodebluetoothmanagerdestroyed|BluetoothManagerDestroyed} error code.\n   */\n  destroy() {\n    // Destroy native module object\n    BleModule.destroyClient()\n\n    // Unsubscribe from any subscriptions\n    if (this._scanEventSubscription != null) {\n      this._scanEventSubscription.remove()\n      this._scanEventSubscription = null\n    }\n    this._destroySubscriptions()\n\n    // Destroy all promises\n    this._destroyPromises()\n  }\n\n  /**\n   * Generates new unique identifier to be used internally.\n   *\n   * @returns {string} New identifier.\n   * @private\n   */\n  _nextUniqueID(): string {\n    this._uniqueId += 1\n    return this._uniqueId.toString()\n  }\n\n  /**\n   * Calls promise and checks if it completed successfully\n   *\n   * @param {Promise<T>} promise Promise to be called\n   * @returns {Promise<T>} Value of called promise.\n   * @private\n   */\n  async _callPromise<T>(promise: Promise<T>): Promise<T> {\n    const id = this._nextUniqueID()\n    try {\n      const destroyPromise = new Promise((resolve, reject) => {\n        this._activePromises[id] = reject\n      })\n      const value = await Promise.race([destroyPromise, promise])\n      delete this._activePromises[id]\n      return value\n    } catch (error) {\n      delete this._activePromises[id]\n      throw parseBleError(error.message, this._errorCodesToMessagesMapping)\n    }\n  }\n\n  // Mark: Common ------------------------------------------------------------------------------------------------------\n\n  /**\n   * Sets new log level for native module's logging mechanism.\n   * @param {LogLevel} logLevel New log level to be set.\n   */\n  setLogLevel(logLevel: $Keys<typeof LogLevel>) {\n    BleModule.setLogLevel(logLevel)\n  }\n\n  /**\n   * Get current log level for native module's logging mechanism.\n   * @returns {Promise<LogLevel>} Current log level.\n   */\n  logLevel(): Promise<$Keys<typeof LogLevel>> {\n    return this._callPromise(BleModule.logLevel())\n  }\n\n  /**\n   * Cancels pending transaction.\n   *\n   * Few operations such as monitoring characteristic's value changes can be cancelled by a user. Basically every API\n   * entry which accepts `transactionId` allows to call `cancelTransaction` function. When cancelled operation is a\n   * promise or a callback which registers errors, {@link #bleerror|BleError} with error code\n   * {@link #bleerrorcodeoperationcancelled|OperationCancelled} will be emitted in that case. Cancelling transaction\n   * which doesn't exist is ignored.\n   *\n   * @example\n   * const transactionId = 'monitor_battery';\n   *\n   * // Monitor battery notifications\n   * manager.monitorCharacteristicForDevice(\n   *   device.id, '180F', '2A19',\n   *   (error, characteristic) => {\n   *   // Handle battery level changes...\n   * }, transactionId);\n   *\n   * // Cancel after specified amount of time\n   * setTimeout(() => manager.cancelTransaction(transactionId), 2000);\n   *\n   * @param {TransactionId} transactionId Id of pending transactions.\n   */\n  cancelTransaction(transactionId: TransactionId) {\n    BleModule.cancelTransaction(transactionId)\n  }\n\n  // Mark: Monitoring state --------------------------------------------------------------------------------------------\n\n  /**\n   * Enable Bluetooth. This function blocks until BLE is in PoweredOn state. [Android only]\n   *\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<BleManager>} Promise completes when state transition was successful.\n   */\n  async enable(transactionId: ?TransactionId): Promise<BleManager> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    await this._callPromise(BleModule.enable(transactionId))\n    return this\n  }\n\n  /**\n   * Disable Bluetooth. This function blocks until BLE is in PoweredOff state. [Android only]\n   *\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<BleManager>} Promise completes when state transition was successful.\n   */\n  async disable(transactionId: ?TransactionId): Promise<BleManager> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    await this._callPromise(BleModule.disable(transactionId))\n    return this\n  }\n\n  /**\n   * Current, global {@link State} of a {@link BleManager}. All APIs are working only when active state\n   * is \"PoweredOn\".\n   *\n   * @returns {Promise<State>} Promise which emits current state of BleManager.\n   */\n  state(): Promise<$Keys<typeof State>> {\n    return this._callPromise(BleModule.state())\n  }\n\n  /**\n   * Notifies about {@link State} changes of a {@link BleManager}.\n   *\n   * @example\n   * const subscription = this.manager.onStateChange((state) => {\n   *      if (state === 'PoweredOn') {\n   *          this.scanAndConnect();\n   *          subscription.remove();\n   *      }\n   *  }, true);\n   *\n   * @param {function(newState: State)} listener Callback which emits state changes of BLE Manager.\n   * Look at {@link State} for possible values.\n   * @param {boolean} [emitCurrentState=false] If true, current state will be emitted as well. Defaults to false.\n   *\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  onStateChange(listener: (newState: $Keys<typeof State>) => void, emitCurrentState: boolean = false): Subscription {\n    const subscription: Subscription = this._eventEmitter.addListener(BleModule.StateChangeEvent, listener)\n    const id = this._nextUniqueID()\n    var wrappedSubscription: Subscription\n\n    if (emitCurrentState) {\n      var cancelled = false\n      this._callPromise(this.state()).then(currentState => {\n        if (!cancelled) {\n          listener(currentState)\n        }\n      })\n\n      wrappedSubscription = {\n        remove: () => {\n          if (this._activeSubscriptions[id] != null) {\n            cancelled = true\n            delete this._activeSubscriptions[id]\n            subscription.remove()\n          }\n        }\n      }\n    } else {\n      wrappedSubscription = {\n        remove: () => {\n          if (this._activeSubscriptions[id] != null) {\n            delete this._activeSubscriptions[id]\n            subscription.remove()\n          }\n        }\n      }\n    }\n\n    this._activeSubscriptions[id] = wrappedSubscription\n    return wrappedSubscription\n  }\n\n  // Mark: Scanning ----------------------------------------------------------------------------------------------------\n\n  /**\n   * Starts device scanning. When previous scan is in progress it will be stopped before executing this command.\n   *\n   * @param {?Array<UUID>} UUIDs Array of strings containing {@link UUID}s of {@link Service}s which are registered in\n   * scanned {@link Device}. If `null` is passed, all available {@link Device}s will be scanned.\n   * @param {?ScanOptions} options Optional configuration for scanning operation.\n   * @param {function(error: ?BleError, scannedDevice: ?Device)} listener Function which will be called for every scanned\n   * {@link Device} (devices may be scanned multiple times). It's first argument is potential {@link Error} which is set\n   * to non `null` value when scanning failed. You have to start scanning process again if that happens. Second argument\n   * is a scanned {@link Device}.\n   */\n  startDeviceScan(\n    UUIDs: ?Array<UUID>,\n    options: ?ScanOptions,\n    listener: (error: ?BleError, scannedDevice: ?Device) => void\n  ) {\n    this.stopDeviceScan()\n    const scanListener = ([error, nativeDevice]: [?string, ?NativeDevice]) => {\n      listener(\n        error ? parseBleError(error, this._errorCodesToMessagesMapping) : null,\n        nativeDevice ? new Device(nativeDevice, this) : null\n      )\n    }\n    // $FlowFixMe: Flow cannot deduce EmitterSubscription type.\n    this._scanEventSubscription = this._eventEmitter.addListener(BleModule.ScanEvent, scanListener)\n    BleModule.startDeviceScan(UUIDs, options)\n  }\n\n  /**\n   * Stops {@link Device} scan if in progress.\n   */\n  stopDeviceScan() {\n    if (this._scanEventSubscription != null) {\n      this._scanEventSubscription.remove()\n      this._scanEventSubscription = null\n    }\n    BleModule.stopDeviceScan()\n  }\n\n  /**\n   * Request a connection parameter update. This functions may update connection parameters on Android API level 21 or\n   * above.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @param {ConnectionPriority} connectionPriority: Connection priority.\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation.\n   * @returns {Promise<Device>} Connected device.\n   */\n  async requestConnectionPriorityForDevice(\n    deviceIdentifier: DeviceId,\n    connectionPriority: $Values<typeof ConnectionPriority>,\n    transactionId: ?TransactionId\n  ): Promise<Device> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDevice = await this._callPromise(\n      BleModule.requestConnectionPriorityForDevice(deviceIdentifier, connectionPriority, transactionId)\n    )\n    return new Device(nativeDevice, this)\n  }\n\n  /**\n   * Reads RSSI for connected device.\n   *\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Device>} Connected device with updated RSSI value.\n   */\n  async readRSSIForDevice(deviceIdentifier: DeviceId, transactionId: ?TransactionId): Promise<Device> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDevice = await this._callPromise(BleModule.readRSSIForDevice(deviceIdentifier, transactionId))\n    return new Device(nativeDevice, this)\n  }\n\n  /**\n   * Request new MTU value for this device. This function currently is not doing anything\n   * on iOS platform as MTU exchange is done automatically.\n   * @param {DeviceId} deviceIdentifier Device identifier.\n   * @param {number} mtu New MTU to negotiate.\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Device>} Device with updated MTU size. Default value is 23.\n   */\n  async requestMTUForDevice(deviceIdentifier: DeviceId, mtu: number, transactionId: ?TransactionId): Promise<Device> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDevice = await this._callPromise(BleModule.requestMTUForDevice(deviceIdentifier, mtu, transactionId))\n    return new Device(nativeDevice, this)\n  }\n\n  // Mark: Connection management ---------------------------------------------------------------------------------------\n\n  /**\n   * Returns a list of known devices by their identifiers.\n   * @param {Array<DeviceId>} deviceIdentifiers List of device identifiers.\n   * @returns {Promise<Array<Device>>} List of known devices by their identifiers.\n   */\n  async devices(deviceIdentifiers: Array<DeviceId>): Promise<Array<Device>> {\n    const nativeDevices = await this._callPromise(BleModule.devices(deviceIdentifiers))\n    return nativeDevices.map((nativeDevice: NativeDevice) => {\n      return new Device(nativeDevice, this)\n    })\n  }\n\n  /**\n   * Returns a list of the peripherals (containing any of the specified services) currently connected to the system\n   * which have discovered services. Returned devices **may not be connected** to your application. Make sure to check\n   * if that's the case with function {@link #blemanagerisdeviceconnected|isDeviceConnected}.\n   * @param {Array<UUID>} serviceUUIDs List of service UUIDs. Device must contain at least one of them to be listed.\n   * @returns {Promise<Array<Device>>} List of known devices with discovered services as stated in the parameter.\n   */\n  async connectedDevices(serviceUUIDs: Array<UUID>): Promise<Array<Device>> {\n    const nativeDevices = await this._callPromise(BleModule.connectedDevices(serviceUUIDs))\n    return nativeDevices.map((nativeDevice: NativeDevice) => {\n      return new Device(nativeDevice, this)\n    })\n  }\n\n  // Mark: Connection management ---------------------------------------------------------------------------------------\n\n  /**\n   * Connects to {@link Device} with provided ID.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {?ConnectionOptions} options Platform specific options for connection establishment.\n   * @returns {Promise<Device>} Connected {@link Device} object if successful.\n   */\n  async connectToDevice(deviceIdentifier: DeviceId, options: ?ConnectionOptions): Promise<Device> {\n    const nativeDevice = await this._callPromise(BleModule.connectToDevice(deviceIdentifier, options))\n    return new Device(nativeDevice, this)\n  }\n\n  /**\n   * Disconnects from {@link Device} if it's connected or cancels pending connection.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier to be closed.\n   * @returns {Promise<Device>} Returns closed {@link Device} when operation is successful.\n   */\n  async cancelDeviceConnection(deviceIdentifier: DeviceId): Promise<Device> {\n    const nativeDevice = await this._callPromise(BleModule.cancelDeviceConnection(deviceIdentifier))\n    return new Device(nativeDevice, this)\n  }\n\n  /**\n   * Monitors if {@link Device} was disconnected due to any errors or connection problems.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier to be monitored.\n   * @param {function(error: ?BleError, device: Device)} listener - callback returning error as a reason of disconnection\n   * if available and {@link Device} object. If an error is null, that means the connection was terminated by\n   * {@link #blemanagercanceldeviceconnection|bleManager.cancelDeviceConnection()} call.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  onDeviceDisconnected(deviceIdentifier: DeviceId, listener: (error: ?BleError, device: Device) => void): Subscription {\n    const disconnectionListener = ([error, nativeDevice]: [?string, NativeDevice]) => {\n      if (deviceIdentifier !== nativeDevice.id) return\n      listener(error ? parseBleError(error, this._errorCodesToMessagesMapping) : null, new Device(nativeDevice, this))\n    }\n\n    const subscription: Subscription = this._eventEmitter.addListener(\n      BleModule.DisconnectionEvent,\n      disconnectionListener\n    )\n\n    const id = this._nextUniqueID()\n    const wrappedSubscription = {\n      remove: () => {\n        if (this._activeSubscriptions[id] != null) {\n          delete this._activeSubscriptions[id]\n          subscription.remove()\n        }\n      }\n    }\n    this._activeSubscriptions[id] = wrappedSubscription\n    return wrappedSubscription\n  }\n\n  /**\n   * Check connection state of a {@link Device}.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @returns {Promise<boolean>} Promise which emits `true` if device is connected, and `false` otherwise.\n   */\n  isDeviceConnected(deviceIdentifier: DeviceId): Promise<boolean> {\n    return this._callPromise(BleModule.isDeviceConnected(deviceIdentifier))\n  }\n\n  // Mark: Discovery ---------------------------------------------------------------------------------------------------\n\n  /**\n   * Discovers all {@link Service}s,  {@link Characteristic}s and {@link Descriptor}s for {@link Device}.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Device>} Promise which emits {@link Device} object if all available services and\n   * characteristics have been discovered.\n   */\n  async discoverAllServicesAndCharacteristicsForDevice(\n    deviceIdentifier: DeviceId,\n    transactionId: ?TransactionId\n  ): Promise<Device> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDevice = await this._callPromise(\n      BleModule.discoverAllServicesAndCharacteristicsForDevice(deviceIdentifier, transactionId)\n    )\n    return new Device(nativeDevice, this)\n  }\n\n  // Mark: Service and characteristic getters --------------------------------------------------------------------------\n\n  /**\n   * List of discovered {@link Service}s for {@link Device}.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @returns {Promise<Array<Service>>} Promise which emits array of {@link Service} objects which are discovered for a\n   * {@link Device}.\n   */\n  async servicesForDevice(deviceIdentifier: DeviceId): Promise<Array<Service>> {\n    const services = await this._callPromise(BleModule.servicesForDevice(deviceIdentifier))\n    return services.map(nativeService => {\n      return new Service(nativeService, this)\n    })\n  }\n\n  /**\n   * List of discovered {@link Characteristic}s for given {@link Device} and {@link Service}.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @returns {Promise<Array<Characteristic>>} Promise which emits array of {@link Characteristic} objects which are\n   * discovered for a {@link Device} in specified {@link Service}.\n   */\n  characteristicsForDevice(deviceIdentifier: DeviceId, serviceUUID: UUID): Promise<Array<Characteristic>> {\n    return this._handleCharacteristics(BleModule.characteristicsForDevice(deviceIdentifier, serviceUUID))\n  }\n\n  /**\n   * List of discovered {@link Characteristic}s for unique {@link Service}.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} ID.\n   * @returns {Promise<Array<Characteristic>>} Promise which emits array of {@link Characteristic} objects which are\n   * discovered in unique {@link Service}.\n   * @private\n   */\n  _characteristicsForService(serviceIdentifier: Identifier): Promise<Array<Characteristic>> {\n    return this._handleCharacteristics(BleModule.characteristicsForService(serviceIdentifier))\n  }\n\n  /**\n   * Common code for handling NativeCharacteristic fetches.\n   *\n   * @param {Promise<Array<NativeCharacteristic>>} characteristicsPromise Native characteristics.\n   * @returns {Promise<Array<Characteristic>>} Promise which emits array of {@link Characteristic} objects which are\n   * discovered in unique {@link Service}.\n   * @private\n   */\n  async _handleCharacteristics(\n    characteristicsPromise: Promise<Array<NativeCharacteristic>>\n  ): Promise<Array<Characteristic>> {\n    const characteristics = await this._callPromise(characteristicsPromise)\n    return characteristics.map(nativeCharacteristic => {\n      return new Characteristic(nativeCharacteristic, this)\n    })\n  }\n\n  /**\n   * List of discovered {@link Descriptor}s for given {@link Device}, {@link Service} and {@link Characteristic}.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered for a {@link Device}, {@link Service} in specified {@link Characteristic}.\n   */\n  descriptorsForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID\n  ): Promise<Array<Descriptor>> {\n    return this._handleDescriptors(BleModule.descriptorsForDevice(deviceIdentifier, serviceUUID, characteristicUUID))\n  }\n\n  /**\n   * List of discovered {@link Descriptor}s for given {@link Service} and {@link Characteristic}.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} identifier.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered for a {@link Service} in specified {@link Characteristic}.\n   * @private\n   */\n  _descriptorsForService(serviceIdentifier: Identifier, characteristicUUID: UUID): Promise<Array<Descriptor>> {\n    return this._handleDescriptors(BleModule.descriptorsForService(serviceIdentifier, characteristicUUID))\n  }\n\n  /**\n   * List of discovered {@link Descriptor}s for given {@link Characteristic}.\n   *\n   * @param {Identifier} characteristicIdentifier {@link Characteristic} identifier.\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered in specified {@link Characteristic}.\n   * @private\n   */\n  _descriptorsForCharacteristic(characteristicIdentifier: Identifier): Promise<Array<Descriptor>> {\n    return this._handleDescriptors(BleModule.descriptorsForCharacteristic(characteristicIdentifier))\n  }\n\n  /**\n   *  Common code for handling NativeDescriptor fetches.\n   * @param {Promise<Array<NativeDescriptor>>} descriptorsPromise Native descriptors.\n   * @returns {Promise<Array<Descriptor>>} Promise which emits array of {@link Descriptor} objects which are\n   * discovered in unique {@link Characteristic}.\n   * @private\n   */\n  async _handleDescriptors(descriptorsPromise: Promise<Array<NativeDescriptor>>): Promise<Array<Descriptor>> {\n    const descriptors = await this._callPromise(descriptorsPromise)\n    return descriptors.map(nativeDescriptor => {\n      return new Descriptor(nativeDescriptor, this)\n    })\n  }\n\n  // Mark: Characteristics operations ----------------------------------------------------------------------------------\n\n  /**\n   * Read {@link Characteristic} value.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of {@link Characteristic} will be stored inside returned object.\n   */\n  async readCharacteristicForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.readCharacteristicForDevice(deviceIdentifier, serviceUUID, characteristicUUID, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Read {@link Characteristic} value.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} ID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of {@link Characteristic} will be stored inside returned object.\n   * @private\n   */\n  async _readCharacteristicForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.readCharacteristicForService(serviceIdentifier, characteristicUUID, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Read {@link Characteristic} value.\n   *\n   * @param {Identifier} characteristicIdentifier {@link Characteristic} ID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified ID.\n   * Latest value of {@link Characteristic} will be stored inside returned object.\n   * @private\n   */\n  async _readCharacteristic(\n    characteristicIdentifier: Identifier,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.readCharacteristic(characteristicIdentifier, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Write {@link Characteristic} value with response.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} base64Value Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of characteristic may not be stored inside returned object.\n   */\n  async writeCharacteristicWithResponseForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    base64Value: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.writeCharacteristicForDevice(\n        deviceIdentifier,\n        serviceUUID,\n        characteristicUUID,\n        base64Value,\n        true,\n        transactionId\n      )\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Write {@link Characteristic} value with response.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} ID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} base64Value Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of characteristic may not be stored inside returned object.\n   * @private\n   */\n  async _writeCharacteristicWithResponseForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    base64Value: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.writeCharacteristicForService(serviceIdentifier, characteristicUUID, base64Value, true, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Write {@link Characteristic} value with response.\n   *\n   * @param {Identifier} characteristicIdentifier {@link Characteristic} ID.\n   * @param {Base64} base64Value Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified ID.\n   * Latest value of characteristic may not be stored inside returned object.\n   * @private\n   */\n  async _writeCharacteristicWithResponse(\n    characteristicIdentifier: Identifier,\n    base64Value: Base64,\n    transactionId: ?TransactionId\n  ) {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.writeCharacteristic(characteristicIdentifier, base64Value, true, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Write {@link Characteristic} value without response.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} base64Value Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of characteristic may not be stored inside returned object.\n   */\n  async writeCharacteristicWithoutResponseForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    base64Value: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.writeCharacteristicForDevice(\n        deviceIdentifier,\n        serviceUUID,\n        characteristicUUID,\n        base64Value,\n        false,\n        transactionId\n      )\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Write {@link Characteristic} value without response.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} ID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {Base64} base64Value Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified\n   * UUID paths. Latest value of characteristic may not be stored inside returned object.\n   * @private\n   */\n  async _writeCharacteristicWithoutResponseForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    base64Value: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.writeCharacteristicForService(serviceIdentifier, characteristicUUID, base64Value, false, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Write {@link Characteristic} value without response.\n   *\n   * @param {Identifier} characteristicIdentifier {@link Characteristic} UUID.\n   * @param {Base64} base64Value Value in Base64 format.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Characteristic>} Promise which emits first {@link Characteristic} object matching specified ID.\n   * Latest value of characteristic may not be stored inside returned object.\n   * @private\n   */\n  async _writeCharacteristicWithoutResponse(\n    characteristicIdentifier: Identifier,\n    base64Value: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Characteristic> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeCharacteristic = await this._callPromise(\n      BleModule.writeCharacteristic(characteristicIdentifier, base64Value, false, transactionId)\n    )\n    return new Characteristic(nativeCharacteristic, this)\n  }\n\n  /**\n   * Monitor value changes of a {@link Characteristic}. If notifications are enabled they will be used\n   * in favour of indications.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener - callback which emits\n   * {@link Characteristic} objects with modified value for each notification.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   */\n  monitorCharacteristicForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void,\n    transactionId: ?TransactionId\n  ): Subscription {\n    const filledTransactionId = transactionId || this._nextUniqueID()\n    return this._handleMonitorCharacteristic(\n      BleModule.monitorCharacteristicForDevice(deviceIdentifier, serviceUUID, characteristicUUID, filledTransactionId),\n      filledTransactionId,\n      listener\n    )\n  }\n\n  /**\n   * Monitor value changes of a {@link Characteristic}. If notifications are enabled they will be used\n   * in favour of indications.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} ID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener - callback which emits\n   * {@link Characteristic} objects with modified value for each notification.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   * @private\n   */\n  _monitorCharacteristicForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void,\n    transactionId: ?TransactionId\n  ): Subscription {\n    const filledTransactionId = transactionId || this._nextUniqueID()\n    return this._handleMonitorCharacteristic(\n      BleModule.monitorCharacteristicForService(serviceIdentifier, characteristicUUID, filledTransactionId),\n      filledTransactionId,\n      listener\n    )\n  }\n\n  /**\n   * Monitor value changes of a {@link Characteristic}. If notifications are enabled they will be used\n   * in favour of indications.\n   *\n   * @param {Identifier} characteristicIdentifier - {@link Characteristic} ID.\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener - callback which emits\n   * {@link Characteristic} objects with modified value for each notification.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   * @private\n   */\n  _monitorCharacteristic(\n    characteristicIdentifier: Identifier,\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void,\n    transactionId: ?TransactionId\n  ): Subscription {\n    const filledTransactionId = transactionId || this._nextUniqueID()\n    return this._handleMonitorCharacteristic(\n      BleModule.monitorCharacteristic(characteristicIdentifier, filledTransactionId),\n      filledTransactionId,\n      listener\n    )\n  }\n\n  /**\n   * Common code to handle characteristic monitoring.\n   *\n   * @param {Promise<void>} monitorPromise Characteristic monitoring promise\n   * @param {TransactionId} transactionId TransactionId of passed promise\n   * @param {function(error: ?BleError, characteristic: ?Characteristic)} listener - callback which emits\n   * {@link Characteristic} objects with modified value for each notification.\n   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.\n   * @private\n   */\n  _handleMonitorCharacteristic(\n    monitorPromise: Promise<void>,\n    transactionId: TransactionId,\n    listener: (error: ?BleError, characteristic: ?Characteristic) => void\n  ): Subscription {\n    const monitorListener = ([error, characteristic, msgTransactionId]: [\n      ?string,\n      NativeCharacteristic,\n      TransactionId\n    ]) => {\n      if (transactionId !== msgTransactionId) return\n      if (error) {\n        listener(parseBleError(error, this._errorCodesToMessagesMapping), null)\n        return\n      }\n      listener(null, new Characteristic(characteristic, this))\n    }\n\n    const subscription: Subscription = this._eventEmitter.addListener(BleModule.ReadEvent, monitorListener)\n\n    const id = this._nextUniqueID()\n    const wrappedSubscription: Subscription = {\n      remove: () => {\n        if (this._activeSubscriptions[id] != null) {\n          delete this._activeSubscriptions[id]\n          subscription.remove()\n        }\n      }\n    }\n    this._activeSubscriptions[id] = wrappedSubscription\n\n    this._callPromise(monitorPromise).then(\n      () => {\n        wrappedSubscription.remove()\n      },\n      (error: BleError) => {\n        listener(error, null)\n        wrappedSubscription.remove()\n      }\n    )\n\n    return {\n      remove: () => {\n        BleModule.cancelTransaction(transactionId)\n      }\n    }\n  }\n\n  // Mark: Descriptors operations ----------------------------------------------------------------------------------\n\n  /**\n   * Read {@link Descriptor} value.\n   *\n   * @param {DeviceId} deviceIdentifier {@link Device} identifier.\n   * @param {UUID} serviceUUID {@link Service} UUID.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {UUID} descriptorUUID {@link Descriptor} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   */\n  async readDescriptorForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.readDescriptorForDevice(\n        deviceIdentifier,\n        serviceUUID,\n        characteristicUUID,\n        descriptorUUID,\n        transactionId\n      )\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Read {@link Descriptor} value.\n   *\n   * @param {Identifier} serviceIdentifier {@link Service} identifier.\n   * @param {UUID} characteristicUUID {@link Characteristic} UUID.\n   * @param {UUID} descriptorUUID {@link Descriptor} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   * @private\n   */\n  async _readDescriptorForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.readDescriptorForService(serviceIdentifier, characteristicUUID, descriptorUUID, transactionId)\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Read {@link Descriptor} value.\n   *\n   * @param {Identifier} characteristicIdentifier {@link Characteristic} identifier.\n   * @param {UUID} descriptorUUID {@link Descriptor} UUID.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   * @private\n   */\n  async _readDescriptorForCharacteristic(\n    characteristicIdentifier: Identifier,\n    descriptorUUID: UUID,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.readDescriptorForCharacteristic(characteristicIdentifier, descriptorUUID, transactionId)\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Read {@link Descriptor} value.\n   *\n   * @param {Identifier} descriptorIdentifier {@link Descriptor} identifier.\n   * @param {?TransactionId} transactionId optional `transactionId` which can be used in\n   * {@link #blemanagercanceltransaction|cancelTransaction()} function.\n   * @returns {Promise<Descriptor>} Promise which emits first {@link Descriptor} object matching specified\n   * UUID paths. Latest value of {@link Descriptor} will be stored inside returned object.\n   * @private\n   */\n  async _readDescriptor(descriptorIdentifier: Identifier, transactionId: ?TransactionId): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(BleModule.readDescriptor(descriptorIdentifier, transactionId))\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Write {@link Descriptor} value.\n   *\n   * @param {DeviceId} deviceIdentifier Connected device identifier\n   * @param {UUID} serviceUUID Service UUID\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value\n   */\n  async writeDescriptorForDevice(\n    deviceIdentifier: DeviceId,\n    serviceUUID: UUID,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.writeDescriptorForDevice(\n        deviceIdentifier,\n        serviceUUID,\n        characteristicUUID,\n        descriptorUUID,\n        valueBase64,\n        transactionId\n      )\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Write {@link Descriptor} value.\n   *\n   * @param {Identifier} serviceIdentifier Service identifier\n   * @param {UUID} characteristicUUID Characteristic UUID\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value\n   * @private\n   */\n  async _writeDescriptorForService(\n    serviceIdentifier: Identifier,\n    characteristicUUID: UUID,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.writeDescriptorForService(\n        serviceIdentifier,\n        characteristicUUID,\n        descriptorUUID,\n        valueBase64,\n        transactionId\n      )\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Write {@link Descriptor} value.\n   *\n   * @param {Identifier} characteristicIdentifier Characteristic identifier\n   * @param {UUID} descriptorUUID Descriptor UUID\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value\n   * @private\n   */\n  async _writeDescriptorForCharacteristic(\n    characteristicIdentifier: Identifier,\n    descriptorUUID: UUID,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.writeDescriptorForCharacteristic(characteristicIdentifier, descriptorUUID, valueBase64, transactionId)\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n\n  /**\n   * Write {@link Descriptor} value.\n   *\n   * @param {Identifier} descriptorIdentifier Descriptor identifier\n   * @param {Base64} valueBase64 Value to be set coded in Base64\n   * @param {?TransactionId} transactionId Transaction handle used to cancel operation\n   * @returns {Promise<Descriptor>} Descriptor which saved passed value\n   * @private\n   */\n  async _writeDescriptor(\n    descriptorIdentifier: Identifier,\n    valueBase64: Base64,\n    transactionId: ?TransactionId\n  ): Promise<Descriptor> {\n    if (!transactionId) {\n      transactionId = this._nextUniqueID()\n    }\n    const nativeDescriptor = await this._callPromise(\n      BleModule.writeDescriptor(descriptorIdentifier, valueBase64, transactionId)\n    )\n    return new Descriptor(nativeDescriptor, this)\n  }\n}\n"],"sourceRoot":""}